{"version":3,"file":"index-DgH-xKnr.js","sources":["../../node_modules/jsdoc-type-pratt-parser/dist/index.js","../../node_modules/@storybook/core/dist/docs-tools/index.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.jtpp = {}));\n})(this, (function (exports) { 'use strict';\n\n    function tokenToString(token) {\n        if (token.text !== undefined && token.text !== '') {\n            return `'${token.type}' with value '${token.text}'`;\n        }\n        else {\n            return `'${token.type}'`;\n        }\n    }\n    class NoParsletFoundError extends Error {\n        constructor(token) {\n            super(`No parslet found for token: ${tokenToString(token)}`);\n            this.token = token;\n            Object.setPrototypeOf(this, NoParsletFoundError.prototype);\n        }\n        getToken() {\n            return this.token;\n        }\n    }\n    class EarlyEndOfParseError extends Error {\n        constructor(token) {\n            super(`The parsing ended early. The next token was: ${tokenToString(token)}`);\n            this.token = token;\n            Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);\n        }\n        getToken() {\n            return this.token;\n        }\n    }\n    class UnexpectedTypeError extends Error {\n        constructor(result, message) {\n            let error = `Unexpected type: '${result.type}'.`;\n            if (message !== undefined) {\n                error += ` Message: ${message}`;\n            }\n            super(error);\n            Object.setPrototypeOf(this, UnexpectedTypeError.prototype);\n        }\n    }\n    // export class UnexpectedTokenError extends Error {\n    //   private expected: Token\n    //   private found: Token\n    //\n    //   constructor (expected: Token, found: Token) {\n    //     super(`The parsing ended early. The next token was: ${tokenToString(token)}`)\n    //\n    //     this.token = token\n    //\n    //     Object.setPrototypeOf(this, EarlyEndOfParseError.prototype)\n    //   }\n    //\n    //   getToken() {\n    //     return this.token\n    //   }\n    // }\n\n    function makePunctuationRule(type) {\n        return text => {\n            if (text.startsWith(type)) {\n                return { type, text: type };\n            }\n            else {\n                return null;\n            }\n        };\n    }\n    function getQuoted(text) {\n        let position = 0;\n        let char;\n        const mark = text[0];\n        let escaped = false;\n        if (mark !== '\\'' && mark !== '\"') {\n            return null;\n        }\n        while (position < text.length) {\n            position++;\n            char = text[position];\n            if (!escaped && char === mark) {\n                position++;\n                break;\n            }\n            escaped = !escaped && char === '\\\\';\n        }\n        if (char !== mark) {\n            throw new Error('Unterminated String');\n        }\n        return text.slice(0, position);\n    }\n    const identifierStartRegex = /[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\n    // A hyphen is not technically allowed, but to keep it liberal for now,\n    //  adding it here\n    const identifierContinueRegex = /[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\n    function getIdentifier(text) {\n        let char = text[0];\n        if (!identifierStartRegex.test(char)) {\n            return null;\n        }\n        let position = 1;\n        do {\n            char = text[position];\n            if (!identifierContinueRegex.test(char)) {\n                break;\n            }\n            position++;\n        } while (position < text.length);\n        return text.slice(0, position);\n    }\n    // we are a bit more liberal than TypeScript here and allow `NaN`, `Infinity` and `-Infinity`\n    const numberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n    function getNumber(text) {\n        var _a, _b;\n        return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n    }\n    const identifierRule = text => {\n        const value = getIdentifier(text);\n        if (value == null) {\n            return null;\n        }\n        return {\n            type: 'Identifier',\n            text: value\n        };\n    };\n    function makeKeyWordRule(type) {\n        return text => {\n            if (!text.startsWith(type)) {\n                return null;\n            }\n            const prepends = text[type.length];\n            if (prepends !== undefined && identifierContinueRegex.test(prepends)) {\n                return null;\n            }\n            return {\n                type,\n                text: type\n            };\n        };\n    }\n    const stringValueRule = text => {\n        const value = getQuoted(text);\n        if (value == null) {\n            return null;\n        }\n        return {\n            type: 'StringValue',\n            text: value\n        };\n    };\n    const eofRule = text => {\n        if (text.length > 0) {\n            return null;\n        }\n        return {\n            type: 'EOF',\n            text: ''\n        };\n    };\n    const numberRule = text => {\n        const value = getNumber(text);\n        if (value === null) {\n            return null;\n        }\n        return {\n            type: 'Number',\n            text: value\n        };\n    };\n    const rules = [\n        eofRule,\n        makePunctuationRule('=>'),\n        makePunctuationRule('('),\n        makePunctuationRule(')'),\n        makePunctuationRule('{'),\n        makePunctuationRule('}'),\n        makePunctuationRule('['),\n        makePunctuationRule(']'),\n        makePunctuationRule('|'),\n        makePunctuationRule('&'),\n        makePunctuationRule('<'),\n        makePunctuationRule('>'),\n        makePunctuationRule(','),\n        makePunctuationRule(';'),\n        makePunctuationRule('*'),\n        makePunctuationRule('?'),\n        makePunctuationRule('!'),\n        makePunctuationRule('='),\n        makePunctuationRule(':'),\n        makePunctuationRule('...'),\n        makePunctuationRule('.'),\n        makePunctuationRule('#'),\n        makePunctuationRule('~'),\n        makePunctuationRule('/'),\n        makePunctuationRule('@'),\n        makeKeyWordRule('undefined'),\n        makeKeyWordRule('null'),\n        makeKeyWordRule('function'),\n        makeKeyWordRule('this'),\n        makeKeyWordRule('new'),\n        makeKeyWordRule('module'),\n        makeKeyWordRule('event'),\n        makeKeyWordRule('extends'),\n        makeKeyWordRule('external'),\n        makeKeyWordRule('infer'),\n        makeKeyWordRule('typeof'),\n        makeKeyWordRule('keyof'),\n        makeKeyWordRule('readonly'),\n        makeKeyWordRule('import'),\n        makeKeyWordRule('is'),\n        makeKeyWordRule('in'),\n        makeKeyWordRule('asserts'),\n        numberRule,\n        identifierRule,\n        stringValueRule\n    ];\n    const breakingWhitespaceRegex = /^\\s*\\n\\s*/;\n    class Lexer {\n        static create(text) {\n            const current = this.read(text);\n            text = current.text;\n            const next = this.read(text);\n            text = next.text;\n            return new Lexer(text, undefined, current.token, next.token);\n        }\n        constructor(text, previous, current, next) {\n            this.text = '';\n            this.text = text;\n            this.previous = previous;\n            this.current = current;\n            this.next = next;\n        }\n        static read(text, startOfLine = false) {\n            startOfLine = startOfLine || breakingWhitespaceRegex.test(text);\n            text = text.trim();\n            for (const rule of rules) {\n                const partial = rule(text);\n                if (partial !== null) {\n                    const token = Object.assign(Object.assign({}, partial), { startOfLine });\n                    text = text.slice(token.text.length);\n                    return { text, token };\n                }\n            }\n            throw new Error('Unexpected Token ' + text);\n        }\n        advance() {\n            const next = Lexer.read(this.text);\n            return new Lexer(next.text, this.current, this.next, next.token);\n        }\n    }\n\n    /**\n     * Throws an error if the provided result is not a {@link RootResult}\n     */\n    function assertRootResult(result) {\n        if (result === undefined) {\n            throw new Error('Unexpected undefined');\n        }\n        if (result.type === 'JsdocTypeKeyValue' || result.type === 'JsdocTypeParameterList' ||\n            result.type === 'JsdocTypeProperty' || result.type === 'JsdocTypeReadonlyProperty' ||\n            result.type === 'JsdocTypeObjectField' || result.type === 'JsdocTypeJsdocObjectField' ||\n            result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType' ||\n            result.type === 'JsdocTypeTypeParameter') {\n            throw new UnexpectedTypeError(result);\n        }\n        return result;\n    }\n    function assertPlainKeyValueOrRootResult(result) {\n        if (result.type === 'JsdocTypeKeyValue') {\n            return assertPlainKeyValueResult(result);\n        }\n        return assertRootResult(result);\n    }\n    function assertPlainKeyValueOrNameResult(result) {\n        if (result.type === 'JsdocTypeName') {\n            return result;\n        }\n        return assertPlainKeyValueResult(result);\n    }\n    function assertPlainKeyValueResult(result) {\n        if (result.type !== 'JsdocTypeKeyValue') {\n            throw new UnexpectedTypeError(result);\n        }\n        return result;\n    }\n    function assertNumberOrVariadicNameResult(result) {\n        var _a;\n        if (result.type === 'JsdocTypeVariadic') {\n            if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === 'JsdocTypeName') {\n                return result;\n            }\n            throw new UnexpectedTypeError(result);\n        }\n        if (result.type !== 'JsdocTypeNumber' && result.type !== 'JsdocTypeName') {\n            throw new UnexpectedTypeError(result);\n        }\n        return result;\n    }\n    function assertArrayOrTupleResult(result) {\n        if (result.type === 'JsdocTypeTuple') {\n            return result;\n        }\n        if (result.type === 'JsdocTypeGeneric' && result.meta.brackets === 'square') {\n            return result;\n        }\n        throw new UnexpectedTypeError(result);\n    }\n    function isSquaredProperty(result) {\n        return result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType';\n    }\n\n    // higher precedence = higher importance\n    var Precedence;\n    (function (Precedence) {\n        Precedence[Precedence[\"ALL\"] = 0] = \"ALL\";\n        Precedence[Precedence[\"PARAMETER_LIST\"] = 1] = \"PARAMETER_LIST\";\n        Precedence[Precedence[\"OBJECT\"] = 2] = \"OBJECT\";\n        Precedence[Precedence[\"KEY_VALUE\"] = 3] = \"KEY_VALUE\";\n        Precedence[Precedence[\"INDEX_BRACKETS\"] = 4] = \"INDEX_BRACKETS\";\n        Precedence[Precedence[\"UNION\"] = 5] = \"UNION\";\n        Precedence[Precedence[\"INTERSECTION\"] = 6] = \"INTERSECTION\";\n        Precedence[Precedence[\"PREFIX\"] = 7] = \"PREFIX\";\n        Precedence[Precedence[\"INFIX\"] = 8] = \"INFIX\";\n        Precedence[Precedence[\"TUPLE\"] = 9] = \"TUPLE\";\n        Precedence[Precedence[\"SYMBOL\"] = 10] = \"SYMBOL\";\n        Precedence[Precedence[\"OPTIONAL\"] = 11] = \"OPTIONAL\";\n        Precedence[Precedence[\"NULLABLE\"] = 12] = \"NULLABLE\";\n        Precedence[Precedence[\"KEY_OF_TYPE_OF\"] = 13] = \"KEY_OF_TYPE_OF\";\n        Precedence[Precedence[\"FUNCTION\"] = 14] = \"FUNCTION\";\n        Precedence[Precedence[\"ARROW\"] = 15] = \"ARROW\";\n        Precedence[Precedence[\"ARRAY_BRACKETS\"] = 16] = \"ARRAY_BRACKETS\";\n        Precedence[Precedence[\"GENERIC\"] = 17] = \"GENERIC\";\n        Precedence[Precedence[\"NAME_PATH\"] = 18] = \"NAME_PATH\";\n        Precedence[Precedence[\"PARENTHESIS\"] = 19] = \"PARENTHESIS\";\n        Precedence[Precedence[\"SPECIAL_TYPES\"] = 20] = \"SPECIAL_TYPES\";\n    })(Precedence || (Precedence = {}));\n\n    class Parser {\n        constructor(grammar, textOrLexer, baseParser) {\n            this.grammar = grammar;\n            if (typeof textOrLexer === 'string') {\n                this._lexer = Lexer.create(textOrLexer);\n            }\n            else {\n                this._lexer = textOrLexer;\n            }\n            this.baseParser = baseParser;\n        }\n        get lexer() {\n            return this._lexer;\n        }\n        /**\n         * Parses a given string and throws an error if the parse ended before the end of the string.\n         */\n        parse() {\n            const result = this.parseType(Precedence.ALL);\n            if (this.lexer.current.type !== 'EOF') {\n                throw new EarlyEndOfParseError(this.lexer.current);\n            }\n            return result;\n        }\n        /**\n         * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n         */\n        parseType(precedence) {\n            return assertRootResult(this.parseIntermediateType(precedence));\n        }\n        /**\n         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n         * to parse the state in the infix step.\n         */\n        parseIntermediateType(precedence) {\n            const result = this.tryParslets(null, precedence);\n            if (result === null) {\n                throw new NoParsletFoundError(this.lexer.current);\n            }\n            return this.parseInfixIntermediateType(result, precedence);\n        }\n        /**\n         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n         * a result.\n         */\n        parseInfixIntermediateType(left, precedence) {\n            let result = this.tryParslets(left, precedence);\n            while (result !== null) {\n                left = result;\n                result = this.tryParslets(left, precedence);\n            }\n            return left;\n        }\n        /**\n         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n         */\n        tryParslets(left, precedence) {\n            for (const parslet of this.grammar) {\n                const result = parslet(this, precedence, left);\n                if (result !== null) {\n                    return result;\n                }\n            }\n            return null;\n        }\n        /**\n         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n         * advanced.\n         */\n        consume(types) {\n            if (!Array.isArray(types)) {\n                types = [types];\n            }\n            if (types.includes(this.lexer.current.type)) {\n                this._lexer = this.lexer.advance();\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        acceptLexerState(parser) {\n            this._lexer = parser.lexer;\n        }\n    }\n\n    function isQuestionMarkUnknownType(next) {\n        return next === '}' || next === 'EOF' || next === '|' || next === ',' || next === ')' || next === '>';\n    }\n\n    const nullableParslet = (parser, precedence, left) => {\n        const type = parser.lexer.current.type;\n        const next = parser.lexer.next.type;\n        const accept = ((left == null) && type === '?' && !isQuestionMarkUnknownType(next)) ||\n            ((left != null) && type === '?');\n        if (!accept) {\n            return null;\n        }\n        parser.consume('?');\n        if (left == null) {\n            return {\n                type: 'JsdocTypeNullable',\n                element: parser.parseType(Precedence.NULLABLE),\n                meta: {\n                    position: 'prefix'\n                }\n            };\n        }\n        else {\n            return {\n                type: 'JsdocTypeNullable',\n                element: assertRootResult(left),\n                meta: {\n                    position: 'suffix'\n                }\n            };\n        }\n    };\n\n    function composeParslet(options) {\n        const parslet = (parser, curPrecedence, left) => {\n            const type = parser.lexer.current.type;\n            const next = parser.lexer.next.type;\n            if (left === null) {\n                if ('parsePrefix' in options) {\n                    if (options.accept(type, next)) {\n                        return options.parsePrefix(parser);\n                    }\n                }\n            }\n            else {\n                if ('parseInfix' in options) {\n                    if (options.precedence > curPrecedence && options.accept(type, next)) {\n                        return options.parseInfix(parser, left);\n                    }\n                }\n            }\n            return null;\n        };\n        // for debugging\n        Object.defineProperty(parslet, 'name', {\n            value: options.name\n        });\n        return parslet;\n    }\n\n    const optionalParslet = composeParslet({\n        name: 'optionalParslet',\n        accept: type => type === '=',\n        precedence: Precedence.OPTIONAL,\n        parsePrefix: parser => {\n            parser.consume('=');\n            return {\n                type: 'JsdocTypeOptional',\n                element: parser.parseType(Precedence.OPTIONAL),\n                meta: {\n                    position: 'prefix'\n                }\n            };\n        },\n        parseInfix: (parser, left) => {\n            parser.consume('=');\n            return {\n                type: 'JsdocTypeOptional',\n                element: assertRootResult(left),\n                meta: {\n                    position: 'suffix'\n                }\n            };\n        }\n    });\n\n    const numberParslet = composeParslet({\n        name: 'numberParslet',\n        accept: type => type === 'Number',\n        parsePrefix: parser => {\n            const value = parseFloat(parser.lexer.current.text);\n            parser.consume('Number');\n            return {\n                type: 'JsdocTypeNumber',\n                value\n            };\n        }\n    });\n\n    const parenthesisParslet = composeParslet({\n        name: 'parenthesisParslet',\n        accept: type => type === '(',\n        parsePrefix: parser => {\n            parser.consume('(');\n            if (parser.consume(')')) {\n                return {\n                    type: 'JsdocTypeParameterList',\n                    elements: []\n                };\n            }\n            const result = parser.parseIntermediateType(Precedence.ALL);\n            if (!parser.consume(')')) {\n                throw new Error('Unterminated parenthesis');\n            }\n            if (result.type === 'JsdocTypeParameterList') {\n                return result;\n            }\n            else if (result.type === 'JsdocTypeKeyValue') {\n                return {\n                    type: 'JsdocTypeParameterList',\n                    elements: [result]\n                };\n            }\n            return {\n                type: 'JsdocTypeParenthesis',\n                element: assertRootResult(result)\n            };\n        }\n    });\n\n    const specialTypesParslet = composeParslet({\n        name: 'specialTypesParslet',\n        accept: (type, next) => (type === '?' && isQuestionMarkUnknownType(next)) ||\n            type === 'null' || type === 'undefined' || type === '*',\n        parsePrefix: parser => {\n            if (parser.consume('null')) {\n                return {\n                    type: 'JsdocTypeNull'\n                };\n            }\n            if (parser.consume('undefined')) {\n                return {\n                    type: 'JsdocTypeUndefined'\n                };\n            }\n            if (parser.consume('*')) {\n                return {\n                    type: 'JsdocTypeAny'\n                };\n            }\n            if (parser.consume('?')) {\n                return {\n                    type: 'JsdocTypeUnknown'\n                };\n            }\n            throw new Error('Unacceptable token: ' + parser.lexer.current.text);\n        }\n    });\n\n    const notNullableParslet = composeParslet({\n        name: 'notNullableParslet',\n        accept: type => type === '!',\n        precedence: Precedence.NULLABLE,\n        parsePrefix: parser => {\n            parser.consume('!');\n            return {\n                type: 'JsdocTypeNotNullable',\n                element: parser.parseType(Precedence.NULLABLE),\n                meta: {\n                    position: 'prefix'\n                }\n            };\n        },\n        parseInfix: (parser, left) => {\n            parser.consume('!');\n            return {\n                type: 'JsdocTypeNotNullable',\n                element: assertRootResult(left),\n                meta: {\n                    position: 'suffix'\n                }\n            };\n        }\n    });\n\n    function createParameterListParslet({ allowTrailingComma }) {\n        return composeParslet({\n            name: 'parameterListParslet',\n            accept: type => type === ',',\n            precedence: Precedence.PARAMETER_LIST,\n            parseInfix: (parser, left) => {\n                const elements = [\n                    assertPlainKeyValueOrRootResult(left)\n                ];\n                parser.consume(',');\n                do {\n                    try {\n                        const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);\n                        elements.push(assertPlainKeyValueOrRootResult(next));\n                    }\n                    catch (e) {\n                        if (e instanceof NoParsletFoundError) {\n                            break;\n                        }\n                        else {\n                            throw e;\n                        }\n                    }\n                } while (parser.consume(','));\n                if (elements.length > 0 && elements.slice(0, -1).some(e => e.type === 'JsdocTypeVariadic')) {\n                    throw new Error('Only the last parameter may be a rest parameter');\n                }\n                return {\n                    type: 'JsdocTypeParameterList',\n                    elements\n                };\n            }\n        });\n    }\n\n    const genericParslet = composeParslet({\n        name: 'genericParslet',\n        accept: (type, next) => type === '<' || (type === '.' && next === '<'),\n        precedence: Precedence.GENERIC,\n        parseInfix: (parser, left) => {\n            const dot = parser.consume('.');\n            parser.consume('<');\n            const objects = [];\n            let infer = false;\n            if (parser.consume('infer')) {\n                infer = true;\n                const left = parser.parseIntermediateType(Precedence.SYMBOL);\n                if (left.type !== 'JsdocTypeName') {\n                    throw new UnexpectedTypeError(left, 'A typescript asserts always has to have a name on the left side.');\n                }\n                objects.push(left);\n            }\n            else {\n                do {\n                    objects.push(parser.parseType(Precedence.PARAMETER_LIST));\n                } while (parser.consume(','));\n            }\n            if (!parser.consume('>')) {\n                throw new Error('Unterminated generic parameter list');\n            }\n            return Object.assign(Object.assign({ type: 'JsdocTypeGeneric', left: assertRootResult(left), elements: objects }, (infer ? { infer: true } : {})), { meta: {\n                    brackets: 'angle',\n                    dot\n                } });\n        }\n    });\n\n    const unionParslet = composeParslet({\n        name: 'unionParslet',\n        accept: type => type === '|',\n        precedence: Precedence.UNION,\n        parseInfix: (parser, left) => {\n            parser.consume('|');\n            const elements = [];\n            do {\n                elements.push(parser.parseType(Precedence.UNION));\n            } while (parser.consume('|'));\n            return {\n                type: 'JsdocTypeUnion',\n                elements: [assertRootResult(left), ...elements]\n            };\n        }\n    });\n\n    const baseGrammar = [\n        nullableParslet,\n        optionalParslet,\n        numberParslet,\n        parenthesisParslet,\n        specialTypesParslet,\n        notNullableParslet,\n        createParameterListParslet({\n            allowTrailingComma: true\n        }),\n        genericParslet,\n        unionParslet,\n        optionalParslet\n    ];\n\n    function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar }) {\n        return function namePathParslet(parser, precedence, left) {\n            if ((left == null) || precedence >= Precedence.NAME_PATH) {\n                return null;\n            }\n            const type = parser.lexer.current.type;\n            const next = parser.lexer.next.type;\n            const accept = (type === '.' && next !== '<') ||\n                (type === '[' && (allowSquareBracketsOnAnyType || left.type === 'JsdocTypeName')) ||\n                (allowJsdocNamePaths && (type === '~' || type === '#'));\n            if (!accept) {\n                return null;\n            }\n            let pathType;\n            let brackets = false;\n            if (parser.consume('.')) {\n                pathType = 'property';\n            }\n            else if (parser.consume('[')) {\n                pathType = 'property-brackets';\n                brackets = true;\n            }\n            else if (parser.consume('~')) {\n                pathType = 'inner';\n            }\n            else {\n                parser.consume('#');\n                pathType = 'instance';\n            }\n            const pathParser = pathGrammar !== null\n                ? new Parser(pathGrammar, parser.lexer, parser)\n                : parser;\n            const parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);\n            parser.acceptLexerState(pathParser);\n            let right;\n            switch (parsed.type) {\n                case 'JsdocTypeName':\n                    right = {\n                        type: 'JsdocTypeProperty',\n                        value: parsed.value,\n                        meta: {\n                            quote: undefined\n                        }\n                    };\n                    break;\n                case 'JsdocTypeNumber':\n                    right = {\n                        type: 'JsdocTypeProperty',\n                        value: parsed.value.toString(10),\n                        meta: {\n                            quote: undefined\n                        }\n                    };\n                    break;\n                case 'JsdocTypeStringValue':\n                    right = {\n                        type: 'JsdocTypeProperty',\n                        value: parsed.value,\n                        meta: {\n                            quote: parsed.meta.quote\n                        }\n                    };\n                    break;\n                case 'JsdocTypeSpecialNamePath':\n                    if (parsed.specialType === 'event') {\n                        right = parsed;\n                    }\n                    else {\n                        throw new UnexpectedTypeError(parsed, 'Type \\'JsdocTypeSpecialNamePath\\' is only allowed with specialType \\'event\\'');\n                    }\n                    break;\n                default:\n                    throw new UnexpectedTypeError(parsed, 'Expecting \\'JsdocTypeName\\', \\'JsdocTypeNumber\\', \\'JsdocStringValue\\' or \\'JsdocTypeSpecialNamePath\\'');\n            }\n            if (brackets && !parser.consume(']')) {\n                const token = parser.lexer.current;\n                throw new Error(`Unterminated square brackets. Next token is '${token.type}' ` +\n                    `with text '${token.text}'`);\n            }\n            return {\n                type: 'JsdocTypeNamePath',\n                left: assertRootResult(left),\n                right,\n                pathType\n            };\n        };\n    }\n\n    function createNameParslet({ allowedAdditionalTokens }) {\n        return composeParslet({\n            name: 'nameParslet',\n            accept: type => type === 'Identifier' || type === 'this' || type === 'new' || allowedAdditionalTokens.includes(type),\n            parsePrefix: parser => {\n                const { type, text } = parser.lexer.current;\n                parser.consume(type);\n                return {\n                    type: 'JsdocTypeName',\n                    value: text\n                };\n            }\n        });\n    }\n\n    const stringValueParslet = composeParslet({\n        name: 'stringValueParslet',\n        accept: type => type === 'StringValue',\n        parsePrefix: parser => {\n            const text = parser.lexer.current.text;\n            parser.consume('StringValue');\n            return {\n                type: 'JsdocTypeStringValue',\n                value: text.slice(1, -1),\n                meta: {\n                    quote: text[0] === '\\'' ? 'single' : 'double'\n                }\n            };\n        }\n    });\n\n    function createSpecialNamePathParslet({ pathGrammar, allowedTypes }) {\n        return composeParslet({\n            name: 'specialNamePathParslet',\n            accept: type => allowedTypes.includes(type),\n            parsePrefix: parser => {\n                const type = parser.lexer.current.type;\n                parser.consume(type);\n                if (!parser.consume(':')) {\n                    return {\n                        type: 'JsdocTypeName',\n                        value: type\n                    };\n                }\n                let result;\n                let token = parser.lexer.current;\n                if (parser.consume('StringValue')) {\n                    result = {\n                        type: 'JsdocTypeSpecialNamePath',\n                        value: token.text.slice(1, -1),\n                        specialType: type,\n                        meta: {\n                            quote: token.text[0] === '\\'' ? 'single' : 'double'\n                        }\n                    };\n                }\n                else {\n                    let value = '';\n                    const allowed = ['Identifier', '@', '/'];\n                    while (allowed.some(type => parser.consume(type))) {\n                        value += token.text;\n                        token = parser.lexer.current;\n                    }\n                    result = {\n                        type: 'JsdocTypeSpecialNamePath',\n                        value,\n                        specialType: type,\n                        meta: {\n                            quote: undefined\n                        }\n                    };\n                }\n                const moduleParser = new Parser(pathGrammar, parser.lexer, parser);\n                const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);\n                parser.acceptLexerState(moduleParser);\n                return assertRootResult(moduleResult);\n            }\n        });\n    }\n\n    const basePathGrammar = [\n        createNameParslet({\n            allowedAdditionalTokens: ['external', 'module']\n        }),\n        stringValueParslet,\n        numberParslet,\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: false,\n            allowJsdocNamePaths: true,\n            pathGrammar: null\n        })\n    ];\n    const pathGrammar = [\n        ...basePathGrammar,\n        createSpecialNamePathParslet({\n            allowedTypes: ['event'],\n            pathGrammar: basePathGrammar\n        })\n    ];\n\n    function getParameters(value) {\n        let parameters;\n        if (value.type === 'JsdocTypeParameterList') {\n            parameters = value.elements;\n        }\n        else if (value.type === 'JsdocTypeParenthesis') {\n            parameters = [value.element];\n        }\n        else {\n            throw new UnexpectedTypeError(value);\n        }\n        return parameters.map(p => assertPlainKeyValueOrRootResult(p));\n    }\n    function getUnnamedParameters(value) {\n        const parameters = getParameters(value);\n        if (parameters.some(p => p.type === 'JsdocTypeKeyValue')) {\n            throw new Error('No parameter should be named');\n        }\n        return parameters;\n    }\n    function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {\n        return composeParslet({\n            name: 'functionParslet',\n            accept: (type, next) => type === 'function' || (allowNewAsFunctionKeyword && type === 'new' && next === '('),\n            parsePrefix: parser => {\n                const newKeyword = parser.consume('new');\n                parser.consume('function');\n                const hasParenthesis = parser.lexer.current.type === '(';\n                if (!hasParenthesis) {\n                    if (!allowWithoutParenthesis) {\n                        throw new Error('function is missing parameter list');\n                    }\n                    return {\n                        type: 'JsdocTypeName',\n                        value: 'function'\n                    };\n                }\n                let result = {\n                    type: 'JsdocTypeFunction',\n                    parameters: [],\n                    arrow: false,\n                    constructor: newKeyword,\n                    parenthesis: hasParenthesis\n                };\n                const value = parser.parseIntermediateType(Precedence.FUNCTION);\n                if (allowNamedParameters === undefined) {\n                    result.parameters = getUnnamedParameters(value);\n                }\n                else if (newKeyword && value.type === 'JsdocTypeFunction' && value.arrow) {\n                    result = value;\n                    result.constructor = true;\n                    return result;\n                }\n                else {\n                    result.parameters = getParameters(value);\n                    for (const p of result.parameters) {\n                        if (p.type === 'JsdocTypeKeyValue' && (!allowNamedParameters.includes(p.key))) {\n                            throw new Error(`only allowed named parameters are ${allowNamedParameters.join(', ')} but got ${p.type}`);\n                        }\n                    }\n                }\n                if (parser.consume(':')) {\n                    result.returnType = parser.parseType(Precedence.PREFIX);\n                }\n                else {\n                    if (!allowNoReturnType) {\n                        throw new Error('function is missing return type');\n                    }\n                }\n                return result;\n            }\n        });\n    }\n\n    function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {\n        return composeParslet({\n            name: 'variadicParslet',\n            accept: type => type === '...',\n            precedence: Precedence.PREFIX,\n            parsePrefix: parser => {\n                parser.consume('...');\n                const brackets = allowEnclosingBrackets && parser.consume('[');\n                try {\n                    const element = parser.parseType(Precedence.PREFIX);\n                    if (brackets && !parser.consume(']')) {\n                        throw new Error('Unterminated variadic type. Missing \\']\\'');\n                    }\n                    return {\n                        type: 'JsdocTypeVariadic',\n                        element: assertRootResult(element),\n                        meta: {\n                            position: 'prefix',\n                            squareBrackets: brackets\n                        }\n                    };\n                }\n                catch (e) {\n                    if (e instanceof NoParsletFoundError) {\n                        if (brackets) {\n                            throw new Error('Empty square brackets for variadic are not allowed.');\n                        }\n                        return {\n                            type: 'JsdocTypeVariadic',\n                            meta: {\n                                position: undefined,\n                                squareBrackets: false\n                            }\n                        };\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            },\n            parseInfix: allowPostfix\n                ? (parser, left) => {\n                    parser.consume('...');\n                    return {\n                        type: 'JsdocTypeVariadic',\n                        element: assertRootResult(left),\n                        meta: {\n                            position: 'suffix',\n                            squareBrackets: false\n                        }\n                    };\n                }\n                : undefined\n        });\n    }\n\n    const symbolParslet = composeParslet({\n        name: 'symbolParslet',\n        accept: type => type === '(',\n        precedence: Precedence.SYMBOL,\n        parseInfix: (parser, left) => {\n            if (left.type !== 'JsdocTypeName') {\n                throw new Error('Symbol expects a name on the left side. (Reacting on \\'(\\')');\n            }\n            parser.consume('(');\n            const result = {\n                type: 'JsdocTypeSymbol',\n                value: left.value\n            };\n            if (!parser.consume(')')) {\n                const next = parser.parseIntermediateType(Precedence.SYMBOL);\n                result.element = assertNumberOrVariadicNameResult(next);\n                if (!parser.consume(')')) {\n                    throw new Error('Symbol does not end after value');\n                }\n            }\n            return result;\n        }\n    });\n\n    const arrayBracketsParslet = composeParslet({\n        name: 'arrayBracketsParslet',\n        precedence: Precedence.ARRAY_BRACKETS,\n        accept: (type, next) => type === '[' && next === ']',\n        parseInfix: (parser, left) => {\n            parser.consume('[');\n            parser.consume(']');\n            return {\n                type: 'JsdocTypeGeneric',\n                left: {\n                    type: 'JsdocTypeName',\n                    value: 'Array'\n                },\n                elements: [\n                    assertRootResult(left)\n                ],\n                meta: {\n                    brackets: 'square',\n                    dot: false\n                }\n            };\n        }\n    });\n\n    function createObjectParslet({ objectFieldGrammar, allowKeyTypes }) {\n        return composeParslet({\n            name: 'objectParslet',\n            accept: type => type === '{',\n            parsePrefix: parser => {\n                parser.consume('{');\n                const result = {\n                    type: 'JsdocTypeObject',\n                    meta: {\n                        separator: 'comma'\n                    },\n                    elements: []\n                };\n                if (!parser.consume('}')) {\n                    let separator;\n                    const fieldParser = new Parser(objectFieldGrammar, parser.lexer, parser);\n                    while (true) {\n                        fieldParser.acceptLexerState(parser);\n                        let field = fieldParser.parseIntermediateType(Precedence.OBJECT);\n                        parser.acceptLexerState(fieldParser);\n                        if (field === undefined && allowKeyTypes) {\n                            field = parser.parseIntermediateType(Precedence.OBJECT);\n                        }\n                        let optional = false;\n                        if (field.type === 'JsdocTypeNullable') {\n                            optional = true;\n                            field = field.element;\n                        }\n                        if (field.type === 'JsdocTypeNumber' || field.type === 'JsdocTypeName' || field.type === 'JsdocTypeStringValue') {\n                            let quote;\n                            if (field.type === 'JsdocTypeStringValue') {\n                                quote = field.meta.quote;\n                            }\n                            result.elements.push({\n                                type: 'JsdocTypeObjectField',\n                                key: field.value.toString(),\n                                right: undefined,\n                                optional,\n                                readonly: false,\n                                meta: {\n                                    quote\n                                }\n                            });\n                        }\n                        else if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n                            result.elements.push(field);\n                        }\n                        else {\n                            throw new UnexpectedTypeError(field);\n                        }\n                        if (parser.lexer.current.startOfLine) {\n                            separator = 'linebreak';\n                            // Handle single stray comma/semi-colon\n                            parser.consume(',') || parser.consume(';');\n                        }\n                        else if (parser.consume(',')) {\n                            separator = 'comma';\n                        }\n                        else if (parser.consume(';')) {\n                            separator = 'semicolon';\n                        }\n                        else {\n                            break;\n                        }\n                        const type = parser.lexer.current.type;\n                        if (type === '}') {\n                            break;\n                        }\n                    }\n                    result.meta.separator = separator !== null && separator !== void 0 ? separator : 'comma'; // TODO: use undefined here\n                    if (separator === 'linebreak') {\n                        // TODO: Consume appropriate whitespace\n                        result.meta.propertyIndent = '  ';\n                    }\n                    if (!parser.consume('}')) {\n                        throw new Error('Unterminated record type. Missing \\'}\\'');\n                    }\n                }\n                return result;\n            }\n        });\n    }\n\n    function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {\n        return composeParslet({\n            name: 'objectFieldParslet',\n            precedence: Precedence.KEY_VALUE,\n            accept: type => type === ':',\n            parseInfix: (parser, left) => {\n                var _a;\n                let optional = false;\n                let readonlyProperty = false;\n                if (allowOptional && left.type === 'JsdocTypeNullable') {\n                    optional = true;\n                    left = left.element;\n                }\n                if (allowReadonly && left.type === 'JsdocTypeReadonlyProperty') {\n                    readonlyProperty = true;\n                    left = left.element;\n                }\n                // object parslet uses a special grammar and for the value we want to switch back to the parent\n                const parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;\n                parentParser.acceptLexerState(parser);\n                if (left.type === 'JsdocTypeNumber' || left.type === 'JsdocTypeName' || left.type === 'JsdocTypeStringValue' ||\n                    isSquaredProperty(left)) {\n                    if (isSquaredProperty(left) && !allowSquaredProperties) {\n                        throw new UnexpectedTypeError(left);\n                    }\n                    parentParser.consume(':');\n                    let quote;\n                    if (left.type === 'JsdocTypeStringValue') {\n                        quote = left.meta.quote;\n                    }\n                    const right = parentParser.parseType(Precedence.KEY_VALUE);\n                    parser.acceptLexerState(parentParser);\n                    return {\n                        type: 'JsdocTypeObjectField',\n                        key: isSquaredProperty(left) ? left : left.value.toString(),\n                        right,\n                        optional,\n                        readonly: readonlyProperty,\n                        meta: {\n                            quote\n                        }\n                    };\n                }\n                else {\n                    if (!allowKeyTypes) {\n                        throw new UnexpectedTypeError(left);\n                    }\n                    parentParser.consume(':');\n                    const right = parentParser.parseType(Precedence.KEY_VALUE);\n                    parser.acceptLexerState(parentParser);\n                    return {\n                        type: 'JsdocTypeJsdocObjectField',\n                        left: assertRootResult(left),\n                        right\n                    };\n                }\n            }\n        });\n    }\n\n    function createKeyValueParslet({ allowOptional, allowVariadic }) {\n        return composeParslet({\n            name: 'keyValueParslet',\n            precedence: Precedence.KEY_VALUE,\n            accept: type => type === ':',\n            parseInfix: (parser, left) => {\n                let optional = false;\n                let variadic = false;\n                if (allowOptional && left.type === 'JsdocTypeNullable') {\n                    optional = true;\n                    left = left.element;\n                }\n                if (allowVariadic && left.type === 'JsdocTypeVariadic' && left.element !== undefined) {\n                    variadic = true;\n                    left = left.element;\n                }\n                if (left.type !== 'JsdocTypeName') {\n                    throw new UnexpectedTypeError(left);\n                }\n                parser.consume(':');\n                const right = parser.parseType(Precedence.KEY_VALUE);\n                return {\n                    type: 'JsdocTypeKeyValue',\n                    key: left.value,\n                    right,\n                    optional,\n                    variadic\n                };\n            }\n        });\n    }\n\n    const jsdocBaseGrammar = [\n        ...baseGrammar,\n        createFunctionParslet({\n            allowWithoutParenthesis: true,\n            allowNamedParameters: ['this', 'new'],\n            allowNoReturnType: true,\n            allowNewAsFunctionKeyword: false\n        }),\n        stringValueParslet,\n        createSpecialNamePathParslet({\n            allowedTypes: ['module', 'external', 'event'],\n            pathGrammar\n        }),\n        createVariadicParslet({\n            allowEnclosingBrackets: true,\n            allowPostfix: true\n        }),\n        createNameParslet({\n            allowedAdditionalTokens: ['keyof']\n        }),\n        symbolParslet,\n        arrayBracketsParslet,\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: false,\n            allowJsdocNamePaths: true,\n            pathGrammar\n        })\n    ];\n    const jsdocGrammar = [\n        ...jsdocBaseGrammar,\n        createObjectParslet({\n            // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n            // we leave out the object type deliberately\n            objectFieldGrammar: [\n                createNameParslet({\n                    allowedAdditionalTokens: ['typeof', 'module', 'in']\n                }),\n                createObjectFieldParslet({\n                    allowSquaredProperties: false,\n                    allowKeyTypes: true,\n                    allowOptional: false,\n                    allowReadonly: false\n                }),\n                ...jsdocBaseGrammar\n            ],\n            allowKeyTypes: true\n        }),\n        createKeyValueParslet({\n            allowOptional: true,\n            allowVariadic: true\n        })\n    ];\n\n    const typeOfParslet = composeParslet({\n        name: 'typeOfParslet',\n        accept: type => type === 'typeof',\n        parsePrefix: parser => {\n            parser.consume('typeof');\n            return {\n                type: 'JsdocTypeTypeof',\n                element: parser.parseType(Precedence.KEY_OF_TYPE_OF)\n            };\n        }\n    });\n\n    const objectFieldGrammar$1 = [\n        createNameParslet({\n            allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in']\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n            allowSquaredProperties: false,\n            allowKeyTypes: false,\n            allowOptional: false,\n            allowReadonly: false\n        })\n    ];\n    const closureGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n            allowKeyTypes: false,\n            objectFieldGrammar: objectFieldGrammar$1\n        }),\n        createNameParslet({\n            allowedAdditionalTokens: ['event', 'external', 'in']\n        }),\n        typeOfParslet,\n        createFunctionParslet({\n            allowWithoutParenthesis: false,\n            allowNamedParameters: ['this', 'new'],\n            allowNoReturnType: true,\n            allowNewAsFunctionKeyword: false\n        }),\n        createVariadicParslet({\n            allowEnclosingBrackets: false,\n            allowPostfix: false\n        }),\n        // additional name parslet is needed for some special cases\n        createNameParslet({\n            allowedAdditionalTokens: ['keyof']\n        }),\n        createSpecialNamePathParslet({\n            allowedTypes: ['module'],\n            pathGrammar\n        }),\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: false,\n            allowJsdocNamePaths: true,\n            pathGrammar\n        }),\n        createKeyValueParslet({\n            allowOptional: false,\n            allowVariadic: false\n        }),\n        symbolParslet\n    ];\n\n    const assertsParslet = composeParslet({\n        name: 'assertsParslet',\n        accept: type => type === 'asserts',\n        parsePrefix: (parser) => {\n            parser.consume('asserts');\n            const left = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (left.type !== 'JsdocTypeName') {\n                throw new UnexpectedTypeError(left, 'A typescript asserts always has to have a name on the left side.');\n            }\n            if (!parser.consume('is')) {\n                return {\n                    type: 'JsdocTypeAssertsPlain',\n                    element: left\n                };\n            }\n            return {\n                type: 'JsdocTypeAsserts',\n                left,\n                right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n            };\n        }\n    });\n\n    function createTupleParslet({ allowQuestionMark }) {\n        return composeParslet({\n            name: 'tupleParslet',\n            accept: type => type === '[',\n            parsePrefix: parser => {\n                parser.consume('[');\n                const result = {\n                    type: 'JsdocTypeTuple',\n                    elements: []\n                };\n                if (parser.consume(']')) {\n                    return result;\n                }\n                const typeList = parser.parseIntermediateType(Precedence.ALL);\n                if (typeList.type === 'JsdocTypeParameterList') {\n                    if (typeList.elements[0].type === 'JsdocTypeKeyValue') {\n                        result.elements = typeList.elements.map(assertPlainKeyValueResult);\n                    }\n                    else {\n                        result.elements = typeList.elements.map(assertRootResult);\n                    }\n                }\n                else {\n                    if (typeList.type === 'JsdocTypeKeyValue') {\n                        result.elements = [assertPlainKeyValueResult(typeList)];\n                    }\n                    else {\n                        result.elements = [assertRootResult(typeList)];\n                    }\n                }\n                if (!parser.consume(']')) {\n                    throw new Error('Unterminated \\'[\\'');\n                }\n                if (result.elements.some((e) => e.type === 'JsdocTypeUnknown')) {\n                    throw new Error('Question mark in tuple not allowed');\n                }\n                return result;\n            }\n        });\n    }\n\n    const keyOfParslet = composeParslet({\n        name: 'keyOfParslet',\n        accept: type => type === 'keyof',\n        parsePrefix: parser => {\n            parser.consume('keyof');\n            return {\n                type: 'JsdocTypeKeyof',\n                element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n            };\n        }\n    });\n\n    const importParslet = composeParslet({\n        name: 'importParslet',\n        accept: type => type === 'import',\n        parsePrefix: parser => {\n            parser.consume('import');\n            if (!parser.consume('(')) {\n                throw new Error('Missing parenthesis after import keyword');\n            }\n            const path = parser.parseType(Precedence.PREFIX);\n            if (path.type !== 'JsdocTypeStringValue') {\n                throw new Error('Only string values are allowed as paths for imports');\n            }\n            if (!parser.consume(')')) {\n                throw new Error('Missing closing parenthesis after import keyword');\n            }\n            return {\n                type: 'JsdocTypeImport',\n                element: path\n            };\n        }\n    });\n\n    const readonlyPropertyParslet = composeParslet({\n        name: 'readonlyPropertyParslet',\n        accept: type => type === 'readonly',\n        parsePrefix: parser => {\n            parser.consume('readonly');\n            return {\n                type: 'JsdocTypeReadonlyProperty',\n                element: parser.parseIntermediateType(Precedence.KEY_VALUE)\n            };\n        }\n    });\n\n    const arrowFunctionParslet = composeParslet({\n        name: 'arrowFunctionParslet',\n        precedence: Precedence.ARROW,\n        accept: type => type === '=>',\n        parseInfix: (parser, left) => {\n            parser.consume('=>');\n            return {\n                type: 'JsdocTypeFunction',\n                parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\n                arrow: true,\n                constructor: false,\n                parenthesis: true,\n                returnType: parser.parseType(Precedence.OBJECT)\n            };\n        }\n    });\n\n    const genericArrowFunctionParslet = composeParslet({\n        name: 'genericArrowFunctionParslet',\n        accept: type => type === '<',\n        parsePrefix: (parser) => {\n            const typeParameters = [];\n            parser.consume('<');\n            do {\n                let defaultValue;\n                let name = parser.parseIntermediateType(Precedence.SYMBOL);\n                if (name.type === 'JsdocTypeOptional') {\n                    name = name.element;\n                    defaultValue = parser.parseType(Precedence.SYMBOL);\n                }\n                if (name.type !== 'JsdocTypeName') {\n                    throw new UnexpectedTypeError(name);\n                }\n                let constraint;\n                if (parser.consume('extends')) {\n                    constraint = parser.parseType(Precedence.SYMBOL);\n                    // Got an equal sign\n                    if (constraint.type === 'JsdocTypeOptional') {\n                        constraint = constraint.element;\n                        defaultValue = parser.parseType(Precedence.SYMBOL);\n                    }\n                }\n                const typeParameter = {\n                    type: 'JsdocTypeTypeParameter',\n                    name\n                };\n                if (constraint !== undefined) {\n                    typeParameter.constraint = constraint;\n                }\n                if (defaultValue !== undefined) {\n                    typeParameter.defaultValue = defaultValue;\n                }\n                typeParameters.push(typeParameter);\n                if (parser.consume('>')) {\n                    break;\n                }\n            } while (parser.consume(','));\n            const functionBase = parser.parseIntermediateType(Precedence.SYMBOL);\n            functionBase.typeParameters = typeParameters;\n            return functionBase;\n        }\n    });\n\n    const intersectionParslet = composeParslet({\n        name: 'intersectionParslet',\n        accept: type => type === '&',\n        precedence: Precedence.INTERSECTION,\n        parseInfix: (parser, left) => {\n            parser.consume('&');\n            const elements = [];\n            do {\n                elements.push(parser.parseType(Precedence.INTERSECTION));\n            } while (parser.consume('&'));\n            return {\n                type: 'JsdocTypeIntersection',\n                elements: [assertRootResult(left), ...elements]\n            };\n        }\n    });\n\n    const predicateParslet = composeParslet({\n        name: 'predicateParslet',\n        precedence: Precedence.INFIX,\n        accept: type => type === 'is',\n        parseInfix: (parser, left) => {\n            if (left.type !== 'JsdocTypeName') {\n                throw new UnexpectedTypeError(left, 'A typescript predicate always has to have a name on the left side.');\n            }\n            parser.consume('is');\n            return {\n                type: 'JsdocTypePredicate',\n                left,\n                right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n            };\n        }\n    });\n\n    const objectSquaredPropertyParslet = composeParslet({\n        name: 'objectSquareBracketPropertyParslet',\n        accept: type => type === '[',\n        parsePrefix: parser => {\n            if (parser.baseParser === undefined) {\n                throw new Error('Only allowed inside object grammar');\n            }\n            parser.consume('[');\n            const key = parser.lexer.current.text;\n            parser.consume('Identifier');\n            let result;\n            if (parser.consume(':')) {\n                const parentParser = parser.baseParser;\n                parentParser.acceptLexerState(parser);\n                result = {\n                    type: 'JsdocTypeIndexSignature',\n                    key,\n                    right: parentParser.parseType(Precedence.INDEX_BRACKETS)\n                };\n                parser.acceptLexerState(parentParser);\n            }\n            else if (parser.consume('in')) {\n                const parentParser = parser.baseParser;\n                parentParser.acceptLexerState(parser);\n                result = {\n                    type: 'JsdocTypeMappedType',\n                    key,\n                    right: parentParser.parseType(Precedence.ARRAY_BRACKETS)\n                };\n                parser.acceptLexerState(parentParser);\n            }\n            else {\n                throw new Error('Missing \\':\\' or \\'in\\' inside square bracketed property.');\n            }\n            if (!parser.consume(']')) {\n                throw new Error('Unterminated square brackets');\n            }\n            return result;\n        }\n    });\n\n    const readonlyArrayParslet = composeParslet({\n        name: 'readonlyArrayParslet',\n        accept: type => type === 'readonly',\n        parsePrefix: parser => {\n            parser.consume('readonly');\n            return {\n                type: 'JsdocTypeReadonlyArray',\n                element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))\n            };\n        }\n    });\n\n    const conditionalParslet = composeParslet({\n        name: 'conditionalParslet',\n        precedence: Precedence.INFIX,\n        accept: type => type === 'extends',\n        parseInfix: (parser, left) => {\n            parser.consume('extends');\n            const extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element;\n            // parser.consume('?')\n            const trueType = parser.parseType(Precedence.INFIX);\n            parser.consume(':');\n            return {\n                type: 'JsdocTypeConditional',\n                checksType: assertRootResult(left),\n                extendsType,\n                trueType,\n                falseType: parser.parseType(Precedence.INFIX)\n            };\n        }\n    });\n\n    const objectFieldGrammar = [\n        readonlyPropertyParslet,\n        createNameParslet({\n            allowedAdditionalTokens: ['typeof', 'module', 'keyof', 'event', 'external', 'in']\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n            allowSquaredProperties: true,\n            allowKeyTypes: false,\n            allowOptional: true,\n            allowReadonly: true\n        }),\n        objectSquaredPropertyParslet\n    ];\n    const typescriptGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n            allowKeyTypes: false,\n            objectFieldGrammar\n        }),\n        readonlyArrayParslet,\n        typeOfParslet,\n        keyOfParslet,\n        importParslet,\n        stringValueParslet,\n        createFunctionParslet({\n            allowWithoutParenthesis: true,\n            allowNoReturnType: false,\n            allowNamedParameters: ['this', 'new', 'args'],\n            allowNewAsFunctionKeyword: true\n        }),\n        createTupleParslet({\n            allowQuestionMark: false\n        }),\n        createVariadicParslet({\n            allowEnclosingBrackets: false,\n            allowPostfix: false\n        }),\n        assertsParslet,\n        conditionalParslet,\n        createNameParslet({\n            allowedAdditionalTokens: ['event', 'external', 'in']\n        }),\n        createSpecialNamePathParslet({\n            allowedTypes: ['module'],\n            pathGrammar\n        }),\n        arrayBracketsParslet,\n        arrowFunctionParslet,\n        genericArrowFunctionParslet,\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: true,\n            allowJsdocNamePaths: false,\n            pathGrammar\n        }),\n        intersectionParslet,\n        predicateParslet,\n        createKeyValueParslet({\n            allowVariadic: true,\n            allowOptional: true\n        })\n    ];\n\n    /**\n     * This function parses the given expression in the given mode and produces a {@link RootResult}.\n     * @param expression\n     * @param mode\n     */\n    function parse(expression, mode) {\n        switch (mode) {\n            case 'closure':\n                return (new Parser(closureGrammar, expression)).parse();\n            case 'jsdoc':\n                return (new Parser(jsdocGrammar, expression)).parse();\n            case 'typescript':\n                return (new Parser(typescriptGrammar, expression)).parse();\n        }\n    }\n    /**\n     * This function tries to parse the given expression in multiple modes and returns the first successful\n     * {@link RootResult}. By default it tries `'typescript'`, `'closure'` and `'jsdoc'` in this order. If\n     * no mode was successful it throws the error that was produced by the last parsing attempt.\n     * @param expression\n     * @param modes\n     */\n    function tryParse(expression, modes = ['typescript', 'closure', 'jsdoc']) {\n        let error;\n        for (const mode of modes) {\n            try {\n                return parse(expression, mode);\n            }\n            catch (e) {\n                error = e;\n            }\n        }\n        throw error;\n    }\n\n    function transform(rules, parseResult) {\n        const rule = rules[parseResult.type];\n        if (rule === undefined) {\n            throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);\n        }\n        return rule(parseResult, aParseResult => transform(rules, aParseResult));\n    }\n    function notAvailableTransform(parseResult) {\n        throw new Error('This transform is not available. Are you trying the correct parsing mode?');\n    }\n    function extractSpecialParams(source) {\n        const result = {\n            params: []\n        };\n        for (const param of source.parameters) {\n            if (param.type === 'JsdocTypeKeyValue') {\n                if (param.key === 'this') {\n                    result.this = param.right;\n                }\n                else if (param.key === 'new') {\n                    result.new = param.right;\n                }\n                else {\n                    result.params.push(param);\n                }\n            }\n            else {\n                result.params.push(param);\n            }\n        }\n        return result;\n    }\n\n    function applyPosition(position, target, value) {\n        return position === 'prefix' ? value + target : target + value;\n    }\n    function quote(value, quote) {\n        switch (quote) {\n            case 'double':\n                return `\"${value}\"`;\n            case 'single':\n                return `'${value}'`;\n            case undefined:\n                return value;\n        }\n    }\n    function stringifyRules() {\n        return {\n            JsdocTypeParenthesis: (result, transform) => `(${result.element !== undefined ? transform(result.element) : ''})`,\n            JsdocTypeKeyof: (result, transform) => `keyof ${transform(result.element)}`,\n            JsdocTypeFunction: (result, transform) => {\n                var _a;\n                if (!result.arrow) {\n                    let stringified = result.constructor ? 'new' : 'function';\n                    if (!result.parenthesis) {\n                        return stringified;\n                    }\n                    stringified += `(${result.parameters.map(transform).join(', ')})`;\n                    if (result.returnType !== undefined) {\n                        stringified += `: ${transform(result.returnType)}`;\n                    }\n                    return stringified;\n                }\n                else {\n                    if (result.returnType === undefined) {\n                        throw new Error('Arrow function needs a return type.');\n                    }\n                    let stringified = `${result.typeParameters !== undefined\n                    ? `<${(_a = result.typeParameters.map(transform).join(', ')) !== null && _a !== void 0 ? _a : ''}>`\n                    : ''}(${result.parameters.map(transform).join(', ')}) => ${transform(result.returnType)}`;\n                    if (result.constructor) {\n                        stringified = 'new ' + stringified;\n                    }\n                    return stringified;\n                }\n            },\n            JsdocTypeName: result => result.value,\n            JsdocTypeTuple: (result, transform) => `[${result.elements.map(transform).join(', ')}]`,\n            JsdocTypeVariadic: (result, transform) => result.meta.position === undefined\n                ? '...'\n                : applyPosition(result.meta.position, transform(result.element), '...'),\n            JsdocTypeNamePath: (result, transform) => {\n                const left = transform(result.left);\n                const right = transform(result.right);\n                switch (result.pathType) {\n                    case 'inner':\n                        return `${left}~${right}`;\n                    case 'instance':\n                        return `${left}#${right}`;\n                    case 'property':\n                        return `${left}.${right}`;\n                    case 'property-brackets':\n                        return `${left}[${right}]`;\n                }\n            },\n            JsdocTypeStringValue: result => quote(result.value, result.meta.quote),\n            JsdocTypeAny: () => '*',\n            JsdocTypeGeneric: (result, transform) => {\n                if (result.meta.brackets === 'square') {\n                    const element = result.elements[0];\n                    const transformed = transform(element);\n                    if (element.type === 'JsdocTypeUnion' || element.type === 'JsdocTypeIntersection') {\n                        return `(${transformed})[]`;\n                    }\n                    else {\n                        return `${transformed}[]`;\n                    }\n                }\n                else {\n                    return `${transform(result.left)}${result.meta.dot ? '.' : ''}<${result.infer === true ? 'infer ' : ''}${result.elements.map(transform).join(', ')}>`;\n                }\n            },\n            JsdocTypeImport: (result, transform) => `import(${transform(result.element)})`,\n            JsdocTypeObjectField: (result, transform) => {\n                let text = '';\n                if (result.readonly) {\n                    text += 'readonly ';\n                }\n                if (typeof result.key === 'string') {\n                    text += quote(result.key, result.meta.quote);\n                }\n                else {\n                    text += transform(result.key);\n                }\n                if (result.optional) {\n                    text += '?';\n                }\n                if (result.right === undefined) {\n                    return text;\n                }\n                else {\n                    return text + `: ${transform(result.right)}`;\n                }\n            },\n            JsdocTypeJsdocObjectField: (result, transform) => {\n                return `${transform(result.left)}: ${transform(result.right)}`;\n            },\n            JsdocTypeKeyValue: (result, transform) => {\n                let text = result.key;\n                if (result.optional) {\n                    text += '?';\n                }\n                if (result.variadic) {\n                    text = '...' + text;\n                }\n                if (result.right === undefined) {\n                    return text;\n                }\n                else {\n                    return text + `: ${transform(result.right)}`;\n                }\n            },\n            JsdocTypeSpecialNamePath: result => `${result.specialType}:${quote(result.value, result.meta.quote)}`,\n            JsdocTypeNotNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '!'),\n            JsdocTypeNull: () => 'null',\n            JsdocTypeNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '?'),\n            JsdocTypeNumber: result => result.value.toString(),\n            JsdocTypeObject: (result, transform) => {\n                var _a, _b;\n                return `{${(result.meta.separator === 'linebreak' && result.elements.length > 1\n                ? '\\n' + ((_a = result.meta.propertyIndent) !== null && _a !== void 0 ? _a : '')\n                : '') +\n                result.elements.map(transform).join((result.meta.separator === 'comma' ? ', ' : result.meta.separator === 'linebreak' ? '\\n' + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : '') : '; ')) +\n                (result.meta.separator === 'linebreak' && result.elements.length > 1\n                    ? '\\n'\n                    : '')}}`;\n            },\n            JsdocTypeOptional: (result, transform) => applyPosition(result.meta.position, transform(result.element), '='),\n            JsdocTypeSymbol: (result, transform) => `${result.value}(${result.element !== undefined ? transform(result.element) : ''})`,\n            JsdocTypeTypeof: (result, transform) => `typeof ${transform(result.element)}`,\n            JsdocTypeUndefined: () => 'undefined',\n            JsdocTypeUnion: (result, transform) => result.elements.map(transform).join(' | '),\n            JsdocTypeUnknown: () => '?',\n            JsdocTypeIntersection: (result, transform) => result.elements.map(transform).join(' & '),\n            JsdocTypeProperty: result => quote(result.value, result.meta.quote),\n            JsdocTypePredicate: (result, transform) => `${transform(result.left)} is ${transform(result.right)}`,\n            JsdocTypeIndexSignature: (result, transform) => `[${result.key}: ${transform(result.right)}]`,\n            JsdocTypeMappedType: (result, transform) => `[${result.key} in ${transform(result.right)}]`,\n            JsdocTypeAsserts: (result, transform) => `asserts ${transform(result.left)} is ${transform(result.right)}`,\n            JsdocTypeReadonlyArray: (result, transform) => `readonly ${transform(result.element)}`,\n            JsdocTypeAssertsPlain: (result, transform) => `asserts ${transform(result.element)}`,\n            JsdocTypeConditional: (result, transform) => `${transform(result.checksType)} extends ${transform(result.extendsType)} ? ${transform(result.trueType)} : ${transform(result.falseType)}`,\n            JsdocTypeTypeParameter: (result, transform) => `${transform(result.name)}${result.constraint !== undefined ? ` extends ${transform(result.constraint)}` : ''}${result.defaultValue !== undefined ? ` = ${transform(result.defaultValue)}` : ''}`\n        };\n    }\n    const storedStringifyRules = stringifyRules();\n    function stringify(result) {\n        return transform(storedStringifyRules, result);\n    }\n\n    const reservedWords = [\n        'null',\n        'true',\n        'false',\n        'break',\n        'case',\n        'catch',\n        'class',\n        'const',\n        'continue',\n        'debugger',\n        'default',\n        'delete',\n        'do',\n        'else',\n        'export',\n        'extends',\n        'finally',\n        'for',\n        'function',\n        'if',\n        'import',\n        'in',\n        'instanceof',\n        'new',\n        'return',\n        'super',\n        'switch',\n        'this',\n        'throw',\n        'try',\n        'typeof',\n        'var',\n        'void',\n        'while',\n        'with',\n        'yield'\n    ];\n    function makeName(value) {\n        const result = {\n            type: 'NameExpression',\n            name: value\n        };\n        if (reservedWords.includes(value)) {\n            result.reservedWord = true;\n        }\n        return result;\n    }\n    const catharsisTransformRules = {\n        JsdocTypeOptional: (result, transform) => {\n            const transformed = transform(result.element);\n            transformed.optional = true;\n            return transformed;\n        },\n        JsdocTypeNullable: (result, transform) => {\n            const transformed = transform(result.element);\n            transformed.nullable = true;\n            return transformed;\n        },\n        JsdocTypeNotNullable: (result, transform) => {\n            const transformed = transform(result.element);\n            transformed.nullable = false;\n            return transformed;\n        },\n        JsdocTypeVariadic: (result, transform) => {\n            if (result.element === undefined) {\n                throw new Error('dots without value are not allowed in catharsis mode');\n            }\n            const transformed = transform(result.element);\n            transformed.repeatable = true;\n            return transformed;\n        },\n        JsdocTypeAny: () => ({\n            type: 'AllLiteral'\n        }),\n        JsdocTypeNull: () => ({\n            type: 'NullLiteral'\n        }),\n        JsdocTypeStringValue: result => makeName(quote(result.value, result.meta.quote)),\n        JsdocTypeUndefined: () => ({\n            type: 'UndefinedLiteral'\n        }),\n        JsdocTypeUnknown: () => ({\n            type: 'UnknownLiteral'\n        }),\n        JsdocTypeFunction: (result, transform) => {\n            const params = extractSpecialParams(result);\n            const transformed = {\n                type: 'FunctionType',\n                params: params.params.map(transform)\n            };\n            if (params.this !== undefined) {\n                transformed.this = transform(params.this);\n            }\n            if (params.new !== undefined) {\n                transformed.new = transform(params.new);\n            }\n            if (result.returnType !== undefined) {\n                transformed.result = transform(result.returnType);\n            }\n            return transformed;\n        },\n        JsdocTypeGeneric: (result, transform) => ({\n            type: 'TypeApplication',\n            applications: result.elements.map(o => transform(o)),\n            expression: transform(result.left)\n        }),\n        JsdocTypeSpecialNamePath: result => makeName(result.specialType + ':' + quote(result.value, result.meta.quote)),\n        JsdocTypeName: result => {\n            if (result.value !== 'function') {\n                return makeName(result.value);\n            }\n            else {\n                return {\n                    type: 'FunctionType',\n                    params: []\n                };\n            }\n        },\n        JsdocTypeNumber: result => makeName(result.value.toString()),\n        JsdocTypeObject: (result, transform) => {\n            const transformed = {\n                type: 'RecordType',\n                fields: []\n            };\n            for (const field of result.elements) {\n                if (field.type !== 'JsdocTypeObjectField' && field.type !== 'JsdocTypeJsdocObjectField') {\n                    transformed.fields.push({\n                        type: 'FieldType',\n                        key: transform(field),\n                        value: undefined\n                    });\n                }\n                else {\n                    transformed.fields.push(transform(field));\n                }\n            }\n            return transformed;\n        },\n        JsdocTypeObjectField: (result, transform) => {\n            if (typeof result.key !== 'string') {\n                throw new Error('Index signatures and mapped types are not supported');\n            }\n            return {\n                type: 'FieldType',\n                key: makeName(quote(result.key, result.meta.quote)),\n                value: result.right === undefined ? undefined : transform(result.right)\n            };\n        },\n        JsdocTypeJsdocObjectField: (result, transform) => ({\n            type: 'FieldType',\n            key: transform(result.left),\n            value: transform(result.right)\n        }),\n        JsdocTypeUnion: (result, transform) => ({\n            type: 'TypeUnion',\n            elements: result.elements.map(e => transform(e))\n        }),\n        JsdocTypeKeyValue: (result, transform) => {\n            return {\n                type: 'FieldType',\n                key: makeName(result.key),\n                value: result.right === undefined ? undefined : transform(result.right)\n            };\n        },\n        JsdocTypeNamePath: (result, transform) => {\n            const leftResult = transform(result.left);\n            let rightValue;\n            if (result.right.type === 'JsdocTypeSpecialNamePath') {\n                rightValue = transform(result.right).name;\n            }\n            else {\n                rightValue = quote(result.right.value, result.right.meta.quote);\n            }\n            const joiner = result.pathType === 'inner' ? '~' : result.pathType === 'instance' ? '#' : '.';\n            return makeName(`${leftResult.name}${joiner}${rightValue}`);\n        },\n        JsdocTypeSymbol: result => {\n            let value = '';\n            let element = result.element;\n            let trailingDots = false;\n            if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeVariadic') {\n                if (element.meta.position === 'prefix') {\n                    value = '...';\n                }\n                else {\n                    trailingDots = true;\n                }\n                element = element.element;\n            }\n            if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeName') {\n                value += element.value;\n            }\n            else if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeNumber') {\n                value += element.value.toString();\n            }\n            if (trailingDots) {\n                value += '...';\n            }\n            return makeName(`${result.value}(${value})`);\n        },\n        JsdocTypeParenthesis: (result, transform) => transform(assertRootResult(result.element)),\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeImport: notAvailableTransform,\n        JsdocTypeKeyof: notAvailableTransform,\n        JsdocTypeTuple: notAvailableTransform,\n        JsdocTypeTypeof: notAvailableTransform,\n        JsdocTypeIntersection: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n    };\n    function catharsisTransform(result) {\n        return transform(catharsisTransformRules, result);\n    }\n\n    function getQuoteStyle(quote) {\n        switch (quote) {\n            case undefined:\n                return 'none';\n            case 'single':\n                return 'single';\n            case 'double':\n                return 'double';\n        }\n    }\n    function getMemberType(type) {\n        switch (type) {\n            case 'inner':\n                return 'INNER_MEMBER';\n            case 'instance':\n                return 'INSTANCE_MEMBER';\n            case 'property':\n                return 'MEMBER';\n            case 'property-brackets':\n                return 'MEMBER';\n        }\n    }\n    function nestResults(type, results) {\n        if (results.length === 2) {\n            return {\n                type,\n                left: results[0],\n                right: results[1]\n            };\n        }\n        else {\n            return {\n                type,\n                left: results[0],\n                right: nestResults(type, results.slice(1))\n            };\n        }\n    }\n    const jtpRules = {\n        JsdocTypeOptional: (result, transform) => ({\n            type: 'OPTIONAL',\n            value: transform(result.element),\n            meta: {\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN'\n            }\n        }),\n        JsdocTypeNullable: (result, transform) => ({\n            type: 'NULLABLE',\n            value: transform(result.element),\n            meta: {\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK'\n            }\n        }),\n        JsdocTypeNotNullable: (result, transform) => ({\n            type: 'NOT_NULLABLE',\n            value: transform(result.element),\n            meta: {\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG'\n            }\n        }),\n        JsdocTypeVariadic: (result, transform) => {\n            const transformed = {\n                type: 'VARIADIC',\n                meta: {\n                    syntax: result.meta.position === 'prefix'\n                        ? 'PREFIX_DOTS'\n                        : result.meta.position === 'suffix' ? 'SUFFIX_DOTS' : 'ONLY_DOTS'\n                }\n            };\n            if (result.element !== undefined) {\n                transformed.value = transform(result.element);\n            }\n            return transformed;\n        },\n        JsdocTypeName: result => ({\n            type: 'NAME',\n            name: result.value\n        }),\n        JsdocTypeTypeof: (result, transform) => ({\n            type: 'TYPE_QUERY',\n            name: transform(result.element)\n        }),\n        JsdocTypeTuple: (result, transform) => ({\n            type: 'TUPLE',\n            entries: result.elements.map(transform)\n        }),\n        JsdocTypeKeyof: (result, transform) => ({\n            type: 'KEY_QUERY',\n            value: transform(result.element)\n        }),\n        JsdocTypeImport: result => ({\n            type: 'IMPORT',\n            path: {\n                type: 'STRING_VALUE',\n                quoteStyle: getQuoteStyle(result.element.meta.quote),\n                string: result.element.value\n            }\n        }),\n        JsdocTypeUndefined: () => ({\n            type: 'NAME',\n            name: 'undefined'\n        }),\n        JsdocTypeAny: () => ({\n            type: 'ANY'\n        }),\n        JsdocTypeFunction: (result, transform) => {\n            const specialParams = extractSpecialParams(result);\n            const transformed = {\n                type: result.arrow ? 'ARROW' : 'FUNCTION',\n                params: specialParams.params.map(param => {\n                    if (param.type === 'JsdocTypeKeyValue') {\n                        if (param.right === undefined) {\n                            throw new Error('Function parameter without \\':\\' is not expected to be \\'KEY_VALUE\\'');\n                        }\n                        return {\n                            type: 'NAMED_PARAMETER',\n                            name: param.key,\n                            typeName: transform(param.right)\n                        };\n                    }\n                    else {\n                        return transform(param);\n                    }\n                }),\n                new: null,\n                returns: null\n            };\n            if (specialParams.this !== undefined) {\n                transformed.this = transform(specialParams.this);\n            }\n            else if (!result.arrow) {\n                transformed.this = null;\n            }\n            if (specialParams.new !== undefined) {\n                transformed.new = transform(specialParams.new);\n            }\n            if (result.returnType !== undefined) {\n                transformed.returns = transform(result.returnType);\n            }\n            return transformed;\n        },\n        JsdocTypeGeneric: (result, transform) => {\n            const transformed = {\n                type: 'GENERIC',\n                subject: transform(result.left),\n                objects: result.elements.map(transform),\n                meta: {\n                    syntax: result.meta.brackets === 'square' ? 'SQUARE_BRACKET' : result.meta.dot ? 'ANGLE_BRACKET_WITH_DOT' : 'ANGLE_BRACKET'\n                }\n            };\n            if (result.meta.brackets === 'square' && result.elements[0].type === 'JsdocTypeFunction' && !result.elements[0].parenthesis) {\n                transformed.objects[0] = {\n                    type: 'NAME',\n                    name: 'function'\n                };\n            }\n            return transformed;\n        },\n        JsdocTypeObjectField: (result, transform) => {\n            if (typeof result.key !== 'string') {\n                throw new Error('Index signatures and mapped types are not supported');\n            }\n            if (result.right === undefined) {\n                return {\n                    type: 'RECORD_ENTRY',\n                    key: result.key,\n                    quoteStyle: getQuoteStyle(result.meta.quote),\n                    value: null,\n                    readonly: false\n                };\n            }\n            let right = transform(result.right);\n            if (result.optional) {\n                right = {\n                    type: 'OPTIONAL',\n                    value: right,\n                    meta: {\n                        syntax: 'SUFFIX_KEY_QUESTION_MARK'\n                    }\n                };\n            }\n            return {\n                type: 'RECORD_ENTRY',\n                key: result.key.toString(),\n                quoteStyle: getQuoteStyle(result.meta.quote),\n                value: right,\n                readonly: false\n            };\n        },\n        JsdocTypeJsdocObjectField: () => {\n            throw new Error('Keys may not be typed in jsdoctypeparser.');\n        },\n        JsdocTypeKeyValue: (result, transform) => {\n            if (result.right === undefined) {\n                return {\n                    type: 'RECORD_ENTRY',\n                    key: result.key,\n                    quoteStyle: 'none',\n                    value: null,\n                    readonly: false\n                };\n            }\n            let right = transform(result.right);\n            if (result.optional) {\n                right = {\n                    type: 'OPTIONAL',\n                    value: right,\n                    meta: {\n                        syntax: 'SUFFIX_KEY_QUESTION_MARK'\n                    }\n                };\n            }\n            return {\n                type: 'RECORD_ENTRY',\n                key: result.key,\n                quoteStyle: 'none',\n                value: right,\n                readonly: false\n            };\n        },\n        JsdocTypeObject: (result, transform) => {\n            const entries = [];\n            for (const field of result.elements) {\n                if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n                    entries.push(transform(field));\n                }\n            }\n            return {\n                type: 'RECORD',\n                entries\n            };\n        },\n        JsdocTypeSpecialNamePath: result => {\n            if (result.specialType !== 'module') {\n                throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);\n            }\n            return {\n                type: 'MODULE',\n                value: {\n                    type: 'FILE_PATH',\n                    quoteStyle: getQuoteStyle(result.meta.quote),\n                    path: result.value\n                }\n            };\n        },\n        JsdocTypeNamePath: (result, transform) => {\n            let hasEventPrefix = false;\n            let name;\n            let quoteStyle;\n            if (result.right.type === 'JsdocTypeSpecialNamePath' && result.right.specialType === 'event') {\n                hasEventPrefix = true;\n                name = result.right.value;\n                quoteStyle = getQuoteStyle(result.right.meta.quote);\n            }\n            else {\n                name = result.right.value;\n                quoteStyle = getQuoteStyle(result.right.meta.quote);\n            }\n            const transformed = {\n                type: getMemberType(result.pathType),\n                owner: transform(result.left),\n                name,\n                quoteStyle,\n                hasEventPrefix\n            };\n            if (transformed.owner.type === 'MODULE') {\n                const tModule = transformed.owner;\n                transformed.owner = transformed.owner.value;\n                tModule.value = transformed;\n                return tModule;\n            }\n            else {\n                return transformed;\n            }\n        },\n        JsdocTypeUnion: (result, transform) => nestResults('UNION', result.elements.map(transform)),\n        JsdocTypeParenthesis: (result, transform) => ({\n            type: 'PARENTHESIS',\n            value: transform(assertRootResult(result.element))\n        }),\n        JsdocTypeNull: () => ({\n            type: 'NAME',\n            name: 'null'\n        }),\n        JsdocTypeUnknown: () => ({\n            type: 'UNKNOWN'\n        }),\n        JsdocTypeStringValue: result => ({\n            type: 'STRING_VALUE',\n            quoteStyle: getQuoteStyle(result.meta.quote),\n            string: result.value\n        }),\n        JsdocTypeIntersection: (result, transform) => nestResults('INTERSECTION', result.elements.map(transform)),\n        JsdocTypeNumber: result => ({\n            type: 'NUMBER_VALUE',\n            number: result.value.toString()\n        }),\n        JsdocTypeSymbol: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n    };\n    function jtpTransform(result) {\n        return transform(jtpRules, result);\n    }\n\n    function identityTransformRules() {\n        return {\n            JsdocTypeIntersection: (result, transform) => ({\n                type: 'JsdocTypeIntersection',\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeGeneric: (result, transform) => ({\n                type: 'JsdocTypeGeneric',\n                left: transform(result.left),\n                elements: result.elements.map(transform),\n                meta: {\n                    dot: result.meta.dot,\n                    brackets: result.meta.brackets\n                }\n            }),\n            JsdocTypeNullable: result => result,\n            JsdocTypeUnion: (result, transform) => ({\n                type: 'JsdocTypeUnion',\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeUnknown: result => result,\n            JsdocTypeUndefined: result => result,\n            JsdocTypeTypeof: (result, transform) => ({\n                type: 'JsdocTypeTypeof',\n                element: transform(result.element)\n            }),\n            JsdocTypeSymbol: (result, transform) => {\n                const transformed = {\n                    type: 'JsdocTypeSymbol',\n                    value: result.value\n                };\n                if (result.element !== undefined) {\n                    transformed.element = transform(result.element);\n                }\n                return transformed;\n            },\n            JsdocTypeOptional: (result, transform) => ({\n                type: 'JsdocTypeOptional',\n                element: transform(result.element),\n                meta: {\n                    position: result.meta.position\n                }\n            }),\n            JsdocTypeObject: (result, transform) => ({\n                type: 'JsdocTypeObject',\n                meta: {\n                    separator: 'comma'\n                },\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeNumber: result => result,\n            JsdocTypeNull: result => result,\n            JsdocTypeNotNullable: (result, transform) => ({\n                type: 'JsdocTypeNotNullable',\n                element: transform(result.element),\n                meta: {\n                    position: result.meta.position\n                }\n            }),\n            JsdocTypeSpecialNamePath: result => result,\n            JsdocTypeObjectField: (result, transform) => ({\n                type: 'JsdocTypeObjectField',\n                key: result.key,\n                right: result.right === undefined ? undefined : transform(result.right),\n                optional: result.optional,\n                readonly: result.readonly,\n                meta: result.meta\n            }),\n            JsdocTypeJsdocObjectField: (result, transform) => ({\n                type: 'JsdocTypeJsdocObjectField',\n                left: transform(result.left),\n                right: transform(result.right)\n            }),\n            JsdocTypeKeyValue: (result, transform) => {\n                return {\n                    type: 'JsdocTypeKeyValue',\n                    key: result.key,\n                    right: result.right === undefined ? undefined : transform(result.right),\n                    optional: result.optional,\n                    variadic: result.variadic\n                };\n            },\n            JsdocTypeImport: (result, transform) => ({\n                type: 'JsdocTypeImport',\n                element: transform(result.element)\n            }),\n            JsdocTypeAny: result => result,\n            JsdocTypeStringValue: result => result,\n            JsdocTypeNamePath: result => result,\n            JsdocTypeVariadic: (result, transform) => {\n                const transformed = {\n                    type: 'JsdocTypeVariadic',\n                    meta: {\n                        position: result.meta.position,\n                        squareBrackets: result.meta.squareBrackets\n                    }\n                };\n                if (result.element !== undefined) {\n                    transformed.element = transform(result.element);\n                }\n                return transformed;\n            },\n            JsdocTypeTuple: (result, transform) => ({\n                type: 'JsdocTypeTuple',\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeName: result => result,\n            JsdocTypeFunction: (result, transform) => {\n                const transformed = {\n                    type: 'JsdocTypeFunction',\n                    arrow: result.arrow,\n                    parameters: result.parameters.map(transform),\n                    constructor: result.constructor,\n                    parenthesis: result.parenthesis\n                };\n                if (result.returnType !== undefined) {\n                    transformed.returnType = transform(result.returnType);\n                }\n                return transformed;\n            },\n            JsdocTypeKeyof: (result, transform) => ({\n                type: 'JsdocTypeKeyof',\n                element: transform(result.element)\n            }),\n            JsdocTypeParenthesis: (result, transform) => ({\n                type: 'JsdocTypeParenthesis',\n                element: transform(result.element)\n            }),\n            JsdocTypeProperty: result => result,\n            JsdocTypePredicate: (result, transform) => ({\n                type: 'JsdocTypePredicate',\n                left: transform(result.left),\n                right: transform(result.right)\n            }),\n            JsdocTypeIndexSignature: (result, transform) => ({\n                type: 'JsdocTypeIndexSignature',\n                key: result.key,\n                right: transform(result.right)\n            }),\n            JsdocTypeMappedType: (result, transform) => ({\n                type: 'JsdocTypeMappedType',\n                key: result.key,\n                right: transform(result.right)\n            }),\n            JsdocTypeAsserts: (result, transform) => ({\n                type: 'JsdocTypeAsserts',\n                left: transform(result.left),\n                right: transform(result.right)\n            }),\n            JsdocTypeReadonlyArray: (result, transform) => ({\n                type: 'JsdocTypeReadonlyArray',\n                element: transform(result.element)\n            }),\n            JsdocTypeAssertsPlain: (result, transform) => ({\n                type: 'JsdocTypeAssertsPlain',\n                element: transform(result.element)\n            }),\n            JsdocTypeConditional: (result, transform) => ({\n                type: 'JsdocTypeConditional',\n                checksType: transform(result.checksType),\n                extendsType: transform(result.extendsType),\n                trueType: transform(result.trueType),\n                falseType: transform(result.falseType)\n            }),\n            JsdocTypeTypeParameter: (result, transform) => ({\n                type: 'JsdocTypeTypeParameter',\n                name: transform(result.name),\n                constraint: result.constraint !== undefined ? transform(result.constraint) : undefined,\n                defaultValue: result.defaultValue !== undefined ? transform(result.defaultValue) : undefined\n            })\n        };\n    }\n\n    const visitorKeys = {\n        JsdocTypeAny: [],\n        JsdocTypeFunction: ['parameters', 'returnType'],\n        JsdocTypeGeneric: ['left', 'elements'],\n        JsdocTypeImport: [],\n        JsdocTypeIndexSignature: ['right'],\n        JsdocTypeIntersection: ['elements'],\n        JsdocTypeKeyof: ['element'],\n        JsdocTypeKeyValue: ['right'],\n        JsdocTypeMappedType: ['right'],\n        JsdocTypeName: [],\n        JsdocTypeNamePath: ['left', 'right'],\n        JsdocTypeNotNullable: ['element'],\n        JsdocTypeNull: [],\n        JsdocTypeNullable: ['element'],\n        JsdocTypeNumber: [],\n        JsdocTypeObject: ['elements'],\n        JsdocTypeObjectField: ['right'],\n        JsdocTypeJsdocObjectField: ['left', 'right'],\n        JsdocTypeOptional: ['element'],\n        JsdocTypeParenthesis: ['element'],\n        JsdocTypeSpecialNamePath: [],\n        JsdocTypeStringValue: [],\n        JsdocTypeSymbol: ['element'],\n        JsdocTypeTuple: ['elements'],\n        JsdocTypeTypeof: ['element'],\n        JsdocTypeUndefined: [],\n        JsdocTypeUnion: ['elements'],\n        JsdocTypeUnknown: [],\n        JsdocTypeVariadic: ['element'],\n        JsdocTypeProperty: [],\n        JsdocTypePredicate: ['left', 'right'],\n        JsdocTypeAsserts: ['left', 'right'],\n        JsdocTypeReadonlyArray: ['element'],\n        JsdocTypeAssertsPlain: ['element'],\n        JsdocTypeConditional: ['checksType', 'extendsType', 'trueType', 'falseType'],\n        JsdocTypeTypeParameter: ['name', 'constraint', 'defaultValue']\n    };\n\n    function _traverse(node, parentNode, property, onEnter, onLeave) {\n        onEnter === null || onEnter === void 0 ? void 0 : onEnter(node, parentNode, property);\n        const keysToVisit = visitorKeys[node.type];\n        for (const key of keysToVisit) {\n            const value = node[key];\n            if (value !== undefined) {\n                if (Array.isArray(value)) {\n                    for (const element of value) {\n                        _traverse(element, node, key, onEnter, onLeave);\n                    }\n                }\n                else {\n                    _traverse(value, node, key, onEnter, onLeave);\n                }\n            }\n        }\n        onLeave === null || onLeave === void 0 ? void 0 : onLeave(node, parentNode, property);\n    }\n    /**\n     * A function to traverse an AST. It traverses it depth first.\n     * @param node the node to start traversing at.\n     * @param onEnter node visitor function that will be called on entering the node. This corresponds to preorder traversing.\n     * @param onLeave node visitor function that will be called on leaving the node. This corresponds to postorder traversing.\n     */\n    function traverse(node, onEnter, onLeave) {\n        _traverse(node, undefined, undefined, onEnter, onLeave);\n    }\n\n    exports.catharsisTransform = catharsisTransform;\n    exports.identityTransformRules = identityTransformRules;\n    exports.jtpTransform = jtpTransform;\n    exports.parse = parse;\n    exports.stringify = stringify;\n    exports.stringifyRules = stringifyRules;\n    exports.transform = transform;\n    exports.traverse = traverse;\n    exports.tryParse = tryParse;\n    exports.visitorKeys = visitorKeys;\n\n}));\n","var De = Object.defineProperty;\nvar o = (e, t) => De(e, \"name\", { value: t, configurable: !0 });\n\n// src/docs-tools/argTypes/convert/flow/convert.ts\nimport { UnknownArgTypesError as Te } from \"@storybook/core/preview-errors\";\nvar he = /* @__PURE__ */ o((e) => e.name === \"literal\", \"isLiteral\"), be = /* @__PURE__ */ o((e) => e.value.replace(/['|\"]/g, \"\"), \"toEnumOp\\\ntion\"), Pe = /* @__PURE__ */ o((e) => {\n  switch (e.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      let t = {};\n      return e.signature.properties.forEach((r) => {\n        t[r.key] = d(r.value);\n      }), {\n        name: \"object\",\n        value: t\n      };\n    default:\n      throw new Te({ type: e, language: \"Flow\" });\n  }\n}, \"convertSig\"), d = /* @__PURE__ */ o((e) => {\n  let { name: t, raw: r } = e, n = {};\n  switch (typeof r < \"u\" && (n.raw = r), e.name) {\n    case \"literal\":\n      return { ...n, name: \"other\", value: e.value };\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\":\n      return { ...n, name: t };\n    case \"Array\":\n      return { ...n, name: \"array\", value: e.elements.map(d) };\n    case \"signature\":\n      return { ...n, ...Pe(e) };\n    case \"union\":\n      return e.elements?.every(he) ? { ...n, name: \"enum\", value: e.elements?.map(be) } : { ...n, name: t, value: e.elements?.map(d) };\n    case \"intersection\":\n      return { ...n, name: t, value: e.elements?.map(d) };\n    default:\n      return { ...n, name: \"other\", value: t };\n  }\n}, \"convert\");\n\n// ../node_modules/es-toolkit/dist/object/mapValues.mjs\nfunction j(e, t) {\n  let r = {}, n = Object.keys(e);\n  for (let s = 0; s < n.length; s++) {\n    let i = n[s], p = e[i];\n    r[i] = t(p, i, e);\n  }\n  return r;\n}\no(j, \"mapValues\");\n\n// src/docs-tools/argTypes/convert/utils.ts\nvar W = /^['\"]|['\"]$/g, Se = /* @__PURE__ */ o((e) => e.replace(W, \"\"), \"trimQuotes\"), Oe = /* @__PURE__ */ o((e) => W.test(e), \"includesQuo\\\ntes\"), h = /* @__PURE__ */ o((e) => {\n  let t = Se(e);\n  return Oe(e) || Number.isNaN(Number(t)) ? t : Number(t);\n}, \"parseLiteral\");\n\n// src/docs-tools/argTypes/convert/proptypes/convert.ts\nvar ve = /^\\(.*\\) => /, x = /* @__PURE__ */ o((e) => {\n  let { name: t, raw: r, computed: n, value: s } = e, i = {};\n  switch (typeof r < \"u\" && (i.raw = r), t) {\n    case \"enum\": {\n      let a = n ? s : s.map((c) => h(c.value));\n      return { ...i, name: t, value: a };\n    }\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n      return { ...i, name: t };\n    case \"func\":\n      return { ...i, name: \"function\" };\n    case \"bool\":\n    case \"boolean\":\n      return { ...i, name: \"boolean\" };\n    case \"arrayOf\":\n    case \"array\":\n      return { ...i, name: \"array\", value: s && x(s) };\n    case \"object\":\n      return { ...i, name: t };\n    case \"objectOf\":\n      return { ...i, name: t, value: x(s) };\n    case \"shape\":\n    case \"exact\":\n      let p = j(s, (a) => x(a));\n      return { ...i, name: \"object\", value: p };\n    case \"union\":\n      return { ...i, name: \"union\", value: s.map((a) => x(a)) };\n    case \"instanceOf\":\n    case \"element\":\n    case \"elementType\":\n    default: {\n      if (t?.indexOf(\"|\") > 0)\n        try {\n          let u = t.split(\"|\").map((m) => JSON.parse(m));\n          return { ...i, name: \"enum\", value: u };\n        } catch {\n        }\n      let a = s ? `${t}(${s})` : t, c = ve.test(t) ? \"function\" : \"other\";\n      return { ...i, name: c, value: a };\n    }\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/typescript/convert.ts\nimport { UnknownArgTypesError as we } from \"@storybook/core/preview-errors\";\nvar Ee = /* @__PURE__ */ o((e) => {\n  switch (e.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      let t = {};\n      return e.signature.properties.forEach((r) => {\n        t[r.key] = D(r.value);\n      }), {\n        name: \"object\",\n        value: t\n      };\n    default:\n      throw new we({ type: e, language: \"Typescript\" });\n  }\n}, \"convertSig\"), D = /* @__PURE__ */ o((e) => {\n  let { name: t, raw: r } = e, n = {};\n  switch (typeof r < \"u\" && (n.raw = r), e.name) {\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\":\n      return { ...n, name: t };\n    case \"Array\":\n      return { ...n, name: \"array\", value: e.elements.map(D) };\n    case \"signature\":\n      return { ...n, ...Ee(e) };\n    case \"union\":\n      let s;\n      return e.elements?.every((i) => i.name === \"literal\") ? s = {\n        ...n,\n        name: \"enum\",\n        // @ts-expect-error fix types\n        value: e.elements?.map((i) => h(i.value))\n      } : s = { ...n, name: t, value: e.elements?.map(D) }, s;\n    case \"intersection\":\n      return { ...n, name: t, value: e.elements?.map(D) };\n    default:\n      return { ...n, name: \"other\", value: t };\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/index.ts\nvar b = /* @__PURE__ */ o((e) => {\n  let { type: t, tsType: r, flowType: n } = e;\n  try {\n    if (t != null)\n      return x(t);\n    if (r != null)\n      return D(r);\n    if (n != null)\n      return d(n);\n  } catch (s) {\n    console.error(s);\n  }\n  return null;\n}, \"convert\");\n\n// src/docs-tools/argTypes/docgen/types.ts\nvar je = /* @__PURE__ */ ((s) => (s.JAVASCRIPT = \"JavaScript\", s.FLOW = \"Flow\", s.TYPESCRIPT = \"TypeScript\", s.UNKNOWN = \"Unknown\", s))(je ||\n{});\n\n// src/docs-tools/argTypes/docgen/utils/defaultValue.ts\nvar ke = [\"null\", \"undefined\"];\nfunction T(e) {\n  return ke.some((t) => t === e);\n}\no(T, \"isDefaultValueBlacklisted\");\n\n// src/docs-tools/argTypes/docgen/utils/string.ts\nvar M = /* @__PURE__ */ o((e) => {\n  if (!e)\n    return \"\";\n  if (typeof e == \"string\")\n    return e;\n  throw new Error(`Description: expected string, got: ${JSON.stringify(e)}`);\n}, \"str\");\n\n// src/docs-tools/argTypes/docgen/utils/docgenInfo.ts\nfunction z(e) {\n  return !!e.__docgenInfo;\n}\no(z, \"hasDocgen\");\nfunction $(e) {\n  return e != null && Object.keys(e).length > 0;\n}\no($, \"isValidDocgenSection\");\nfunction Y(e, t) {\n  return z(e) ? e.__docgenInfo[t] : null;\n}\no(Y, \"getDocgenSection\");\nfunction q(e) {\n  return z(e) ? M(e.__docgenInfo.description) : \"\";\n}\no(q, \"getDocgenDescription\");\n\n// ../node_modules/comment-parser/es6/primitives.js\nvar f;\n(function(e) {\n  e.start = \"/**\", e.nostart = \"/***\", e.delim = \"*\", e.end = \"*/\";\n})(f = f || (f = {}));\n\n// ../node_modules/comment-parser/es6/util.js\nfunction k(e) {\n  return /^\\s+$/.test(e);\n}\no(k, \"isSpace\");\nfunction G(e) {\n  let t = e.match(/\\r+$/);\n  return t == null ? [\"\", e] : [e.slice(-t[0].length), e.slice(0, -t[0].length)];\n}\no(G, \"splitCR\");\nfunction y(e) {\n  let t = e.match(/^\\s+/);\n  return t == null ? [\"\", e] : [e.slice(0, t[0].length), e.slice(t[0].length)];\n}\no(y, \"splitSpace\");\nfunction K(e) {\n  return e.split(/\\n/);\n}\no(K, \"splitLines\");\nfunction X(e = {}) {\n  return Object.assign({ tag: \"\", name: \"\", type: \"\", optional: !1, description: \"\", problems: [], source: [] }, e);\n}\no(X, \"seedSpec\");\nfunction F(e = {}) {\n  return Object.assign({ start: \"\", delimiter: \"\", postDelimiter: \"\", tag: \"\", postTag: \"\", name: \"\", postName: \"\", type: \"\", postType: \"\", description: \"\",\n  end: \"\", lineEnd: \"\" }, e);\n}\no(F, \"seedTokens\");\n\n// ../node_modules/comment-parser/es6/parser/block-parser.js\nvar Fe = /^@\\S+/;\nfunction J({ fence: e = \"```\" } = {}) {\n  let t = Je(e), r = /* @__PURE__ */ o((n, s) => t(n) ? !s : s, \"toggleFence\");\n  return /* @__PURE__ */ o(function(s) {\n    let i = [[]], p = !1;\n    for (let a of s)\n      Fe.test(a.tokens.description) && !p ? i.push([a]) : i[i.length - 1].push(a), p = r(a.tokens.description, p);\n    return i;\n  }, \"parseBlock\");\n}\no(J, \"getParser\");\nfunction Je(e) {\n  return typeof e == \"string\" ? (t) => t.split(e).length % 2 === 0 : e;\n}\no(Je, \"getFencer\");\n\n// ../node_modules/comment-parser/es6/parser/source-parser.js\nfunction N({ startLine: e = 0, markers: t = f } = {}) {\n  let r = null, n = e;\n  return /* @__PURE__ */ o(function(i) {\n    let p = i, a = F();\n    if ([a.lineEnd, p] = G(p), [a.start, p] = y(p), r === null && p.startsWith(t.start) && !p.startsWith(t.nostart) && (r = [], a.delimiter =\n    p.slice(0, t.start.length), p = p.slice(t.start.length), [a.postDelimiter, p] = y(p)), r === null)\n      return n++, null;\n    let c = p.trimRight().endsWith(t.end);\n    if (a.delimiter === \"\" && p.startsWith(t.delim) && !p.startsWith(t.end) && (a.delimiter = t.delim, p = p.slice(t.delim.length), [a.postDelimiter,\n    p] = y(p)), c) {\n      let u = p.trimRight();\n      a.end = p.slice(u.length - t.end.length), p = u.slice(0, -t.end.length);\n    }\n    if (a.description = p, r.push({ number: n, source: i, tokens: a }), n++, c) {\n      let u = r.slice();\n      return r = null, u;\n    }\n    return null;\n  }, \"parseSource\");\n}\no(N, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/spec-parser.js\nfunction R({ tokenizers: e }) {\n  return /* @__PURE__ */ o(function(r) {\n    var n;\n    let s = X({ source: r });\n    for (let i of e)\n      if (s = i(s), !((n = s.problems[s.problems.length - 1]) === null || n === void 0) && n.critical)\n        break;\n    return s;\n  }, \"parseSpec\");\n}\no(R, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/tag.js\nfunction P() {\n  return (e) => {\n    let { tokens: t } = e.source[0], r = t.description.match(/\\s*(@(\\S+))(\\s*)/);\n    return r === null ? (e.problems.push({\n      code: \"spec:tag:prefix\",\n      message: 'tag should start with \"@\" symbol',\n      line: e.source[0].number,\n      critical: !0\n    }), e) : (t.tag = r[1], t.postTag = r[3], t.description = t.description.slice(r[0].length), e.tag = r[2], e);\n  };\n}\no(P, \"tagTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/type.js\nfunction S(e = \"compact\") {\n  let t = Re(e);\n  return (r) => {\n    let n = 0, s = [];\n    for (let [a, { tokens: c }] of r.source.entries()) {\n      let u = \"\";\n      if (a === 0 && c.description[0] !== \"{\")\n        return r;\n      for (let m of c.description)\n        if (m === \"{\" && n++, m === \"}\" && n--, u += m, n === 0)\n          break;\n      if (s.push([c, u]), n === 0)\n        break;\n    }\n    if (n !== 0)\n      return r.problems.push({\n        code: \"spec:type:unpaired-curlies\",\n        message: \"unpaired curlies\",\n        line: r.source[0].number,\n        critical: !0\n      }), r;\n    let i = [], p = s[0][0].postDelimiter.length;\n    for (let [a, [c, u]] of s.entries())\n      c.type = u, a > 0 && (c.type = c.postDelimiter.slice(p) + u, c.postDelimiter = c.postDelimiter.slice(0, p)), [c.postType, c.description] =\n      y(c.description.slice(u.length)), i.push(c.type);\n    return i[0] = i[0].slice(1), i[i.length - 1] = i[i.length - 1].slice(0, -1), r.type = t(i), r;\n  };\n}\no(S, \"typeTokenizer\");\nvar Ne = /* @__PURE__ */ o((e) => e.trim(), \"trim\");\nfunction Re(e) {\n  return e === \"compact\" ? (t) => t.map(Ne).join(\"\") : e === \"preserve\" ? (t) => t.join(`\n`) : e;\n}\no(Re, \"getJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/name.js\nvar Ae = /* @__PURE__ */ o((e) => e && e.startsWith('\"') && e.endsWith('\"'), \"isQuoted\");\nfunction O() {\n  let e = /* @__PURE__ */ o((t, { tokens: r }, n) => r.type === \"\" ? t : n, \"typeEnd\");\n  return (t) => {\n    let { tokens: r } = t.source[t.source.reduce(e, 0)], n = r.description.trimLeft(), s = n.split('\"');\n    if (s.length > 1 && s[0] === \"\" && s.length % 2 === 1)\n      return t.name = s[1], r.name = `\"${s[1]}\"`, [r.postName, r.description] = y(n.slice(r.name.length)), t;\n    let i = 0, p = \"\", a = !1, c;\n    for (let m of n) {\n      if (i === 0 && k(m))\n        break;\n      m === \"[\" && i++, m === \"]\" && i--, p += m;\n    }\n    if (i !== 0)\n      return t.problems.push({\n        code: \"spec:name:unpaired-brackets\",\n        message: \"unpaired brackets\",\n        line: t.source[0].number,\n        critical: !0\n      }), t;\n    let u = p;\n    if (p[0] === \"[\" && p[p.length - 1] === \"]\") {\n      a = !0, p = p.slice(1, -1);\n      let m = p.split(\"=\");\n      if (p = m[0].trim(), m[1] !== void 0 && (c = m.slice(1).join(\"=\").trim()), p === \"\")\n        return t.problems.push({\n          code: \"spec:name:empty-name\",\n          message: \"empty name\",\n          line: t.source[0].number,\n          critical: !0\n        }), t;\n      if (c === \"\")\n        return t.problems.push({\n          code: \"spec:name:empty-default\",\n          message: \"empty default value\",\n          line: t.source[0].number,\n          critical: !0\n        }), t;\n      if (!Ae(c) && /=(?!>)/.test(c))\n        return t.problems.push({\n          code: \"spec:name:invalid-default\",\n          message: \"invalid default value syntax\",\n          line: t.source[0].number,\n          critical: !0\n        }), t;\n    }\n    return t.optional = a, t.name = p, r.name = u, c !== void 0 && (t.default = c), [r.postName, r.description] = y(n.slice(r.name.length)),\n    t;\n  };\n}\no(O, \"nameTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/description.js\nfunction v(e = \"compact\", t = f) {\n  let r = A(e);\n  return (n) => (n.description = r(n.source, t), n);\n}\no(v, \"descriptionTokenizer\");\nfunction A(e) {\n  return e === \"compact\" ? Ve : e === \"preserve\" ? Be : e;\n}\no(A, \"getJoiner\");\nfunction Ve(e, t = f) {\n  return e.map(({ tokens: { description: r } }) => r.trim()).filter((r) => r !== \"\").join(\" \");\n}\no(Ve, \"compactJoiner\");\nvar Ce = /* @__PURE__ */ o((e, { tokens: t }, r) => t.type === \"\" ? e : r, \"lineNo\"), _e = /* @__PURE__ */ o(({ tokens: e }) => (e.delimiter ===\n\"\" ? e.start : e.postDelimiter.slice(1)) + e.description, \"getDescription\");\nfunction Be(e, t = f) {\n  if (e.length === 0)\n    return \"\";\n  e[0].tokens.description === \"\" && e[0].tokens.delimiter === t.start && (e = e.slice(1));\n  let r = e[e.length - 1];\n  return r !== void 0 && r.tokens.description === \"\" && r.tokens.end.endsWith(t.end) && (e = e.slice(0, -1)), e = e.slice(e.reduce(Ce, 0)), e.\n  map(_e).join(`\n`);\n}\no(Be, \"preserveJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/index.js\nfunction V({ startLine: e = 0, fence: t = \"```\", spacing: r = \"compact\", markers: n = f, tokenizers: s = [\n  P(),\n  S(r),\n  O(),\n  v(r)\n] } = {}) {\n  if (e < 0 || e % 1 > 0)\n    throw new Error(\"Invalid startLine\");\n  let i = N({ startLine: e, markers: n }), p = J({ fence: t }), a = R({ tokenizers: s }), c = A(r);\n  return function(u) {\n    let m = [];\n    for (let ge of K(u)) {\n      let E = i(ge);\n      if (E === null)\n        continue;\n      let L = p(E), U = L.slice(1).map(a);\n      m.push({\n        description: c(L[0], n),\n        tags: U,\n        source: E,\n        problems: U.reduce((de, xe) => de.concat(xe.problems), [])\n      });\n    }\n    return m;\n  };\n}\no(V, \"getParser\");\n\n// ../node_modules/comment-parser/es6/stringifier/index.js\nfunction Ie(e) {\n  return e.start + e.delimiter + e.postDelimiter + e.tag + e.postTag + e.type + e.postType + e.name + e.postName + e.description + e.end + e.\n  lineEnd;\n}\no(Ie, \"join\");\nfunction C() {\n  return (e) => e.source.map(({ tokens: t }) => Ie(t)).join(`\n`);\n}\no(C, \"getStringifier\");\n\n// ../node_modules/comment-parser/es6/stringifier/inspect.js\nvar Le = {\n  line: 0,\n  start: 0,\n  delimiter: 0,\n  postDelimiter: 0,\n  tag: 0,\n  postTag: 0,\n  name: 0,\n  postName: 0,\n  type: 0,\n  postType: 0,\n  description: 0,\n  end: 0,\n  lineEnd: 0\n};\nvar Mr = Object.keys(Le);\n\n// ../node_modules/comment-parser/es6/index.js\nfunction H(e, t = {}) {\n  return V(t)(e);\n}\no(H, \"parse\");\nvar lo = C();\n\n// src/docs-tools/argTypes/jsdocParser.ts\nimport {\n  parse as Ue,\n  stringifyRules as We,\n  transform as Me\n} from \"jsdoc-type-pratt-parser\";\nfunction ze(e) {\n  return e != null && e.includes(\"@\");\n}\no(ze, \"containsJsDoc\");\nfunction $e(e) {\n  let n = `/**\n` + (e ?? \"\").split(`\n`).map((i) => ` * ${i}`).join(`\n`) + `\n*/`, s = H(n, {\n    spacing: \"preserve\"\n  });\n  if (!s || s.length === 0)\n    throw new Error(\"Cannot parse JSDoc tags.\");\n  return s[0];\n}\no($e, \"parse\");\nvar Ye = {\n  tags: [\"param\", \"arg\", \"argument\", \"returns\", \"ignore\", \"deprecated\"]\n}, Q = /* @__PURE__ */ o((e, t = Ye) => {\n  if (!ze(e))\n    return {\n      includesJsDoc: !1,\n      ignore: !1\n    };\n  let r = $e(e), n = qe(r, t.tags);\n  return n.ignore ? {\n    includesJsDoc: !0,\n    ignore: !0\n  } : {\n    includesJsDoc: !0,\n    ignore: !1,\n    // Always use the parsed description to ensure JSDoc is removed from the description.\n    description: r.description.trim(),\n    extractedTags: n\n  };\n}, \"parseJsDoc\");\nfunction qe(e, t) {\n  let r = {\n    params: null,\n    deprecated: null,\n    returns: null,\n    ignore: !1\n  };\n  for (let n of e.tags)\n    if (!(t !== void 0 && !t.includes(n.tag)))\n      if (n.tag === \"ignore\") {\n        r.ignore = !0;\n        break;\n      } else\n        switch (n.tag) {\n          // arg & argument are aliases for param.\n          case \"param\":\n          case \"arg\":\n          case \"argument\": {\n            let s = Ke(n);\n            s != null && (r.params == null && (r.params = []), r.params.push(s));\n            break;\n          }\n          case \"deprecated\": {\n            let s = Xe(n);\n            s != null && (r.deprecated = s);\n            break;\n          }\n          case \"returns\": {\n            let s = He(n);\n            s != null && (r.returns = s);\n            break;\n          }\n          default:\n            break;\n        }\n  return r;\n}\no(qe, \"extractJsDocTags\");\nfunction Ge(e) {\n  return e.replace(/[\\.-]$/, \"\");\n}\no(Ge, \"normaliseParamName\");\nfunction Ke(e) {\n  if (!e.name || e.name === \"-\")\n    return null;\n  let t = te(e.type);\n  return {\n    name: e.name,\n    type: t,\n    description: ee(e.description),\n    getPrettyName: /* @__PURE__ */ o(() => Ge(e.name), \"getPrettyName\"),\n    getTypeName: /* @__PURE__ */ o(() => t ? re(t) : null, \"getTypeName\")\n  };\n}\no(Ke, \"extractParam\");\nfunction Xe(e) {\n  return e.name ? Z(e.name, e.description) : null;\n}\no(Xe, \"extractDeprecated\");\nfunction Z(e, t) {\n  let r = e === \"\" ? t : `${e} ${t}`;\n  return ee(r);\n}\no(Z, \"joinNameAndDescription\");\nfunction ee(e) {\n  let t = e.replace(/^- /g, \"\").trim();\n  return t === \"\" ? null : t;\n}\no(ee, \"normaliseDescription\");\nfunction He(e) {\n  let t = te(e.type);\n  return t ? {\n    type: t,\n    description: Z(e.name, e.description),\n    getTypeName: /* @__PURE__ */ o(() => re(t), \"getTypeName\")\n  } : null;\n}\no(He, \"extractReturns\");\nvar g = We(), Qe = g.JsdocTypeObject;\ng.JsdocTypeAny = () => \"any\";\ng.JsdocTypeObject = (e, t) => `(${Qe(e, t)})`;\ng.JsdocTypeOptional = (e, t) => t(e.element);\ng.JsdocTypeNullable = (e, t) => t(e.element);\ng.JsdocTypeNotNullable = (e, t) => t(e.element);\ng.JsdocTypeUnion = (e, t) => e.elements.map(t).join(\"|\");\nfunction te(e) {\n  try {\n    return Ue(e, \"typescript\");\n  } catch {\n    return null;\n  }\n}\no(te, \"extractType\");\nfunction re(e) {\n  return Me(g, e);\n}\no(re, \"extractTypeName\");\n\n// src/docs-tools/argTypes/utils.ts\nvar ho = 90, bo = 50;\nfunction B(e) {\n  return e.length > 90;\n}\no(B, \"isTooLongForTypeSummary\");\nfunction oe(e) {\n  return e.length > 50;\n}\no(oe, \"isTooLongForDefaultValueSummary\");\nfunction l(e, t) {\n  return e === t ? { summary: e } : { summary: e, detail: t };\n}\no(l, \"createSummaryValue\");\nvar Po = /* @__PURE__ */ o((e) => e.replace(/\\\\r\\\\n/g, \"\\\\n\"), \"normalizeNewlines\");\n\n// src/docs-tools/argTypes/docgen/flow/createDefaultValue.ts\nfunction ne(e, t) {\n  if (e != null) {\n    let { value: r } = e;\n    if (!T(r))\n      return oe(r) ? l(t?.name, r) : l(r);\n  }\n  return null;\n}\no(ne, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/flow/createType.ts\nfunction se({ name: e, value: t, elements: r, raw: n }) {\n  return t ?? (r != null ? r.map(se).join(\" | \") : n ?? e);\n}\no(se, \"generateUnionElement\");\nfunction Ze({ name: e, raw: t, elements: r }) {\n  return r != null ? l(r.map(se).join(\" | \")) : t != null ? l(t.replace(/^\\|\\s*/, \"\")) : l(e);\n}\no(Ze, \"generateUnion\");\nfunction et({ type: e, raw: t }) {\n  return t != null ? l(t) : l(e);\n}\no(et, \"generateFuncSignature\");\nfunction tt({ type: e, raw: t }) {\n  return t != null ? B(t) ? l(e, t) : l(t) : l(e);\n}\no(tt, \"generateObjectSignature\");\nfunction rt(e) {\n  let { type: t } = e;\n  return t === \"object\" ? tt(e) : et(e);\n}\no(rt, \"generateSignature\");\nfunction ot({ name: e, raw: t }) {\n  return t != null ? B(t) ? l(e, t) : l(t) : l(e);\n}\no(ot, \"generateDefault\");\nfunction ie(e) {\n  if (e == null)\n    return null;\n  switch (e.name) {\n    case \"union\":\n      return Ze(e);\n    case \"signature\":\n      return rt(e);\n    default:\n      return ot(e);\n  }\n}\no(ie, \"createType\");\n\n// src/docs-tools/argTypes/docgen/flow/createPropDef.ts\nvar pe = /* @__PURE__ */ o((e, t) => {\n  let { flowType: r, description: n, required: s, defaultValue: i } = t;\n  return {\n    name: e,\n    type: ie(r),\n    required: s,\n    description: n,\n    defaultValue: ne(i ?? null, r ?? null)\n  };\n}, \"createFlowPropDef\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createDefaultValue.ts\nfunction ae({ defaultValue: e }) {\n  if (e != null) {\n    let { value: t } = e;\n    if (!T(t))\n      return l(t);\n  }\n  return null;\n}\no(ae, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createType.ts\nfunction ce({ tsType: e, required: t }) {\n  if (e == null)\n    return null;\n  let r = e.name;\n  return t || (r = r.replace(\" | undefined\", \"\")), l(\n    [\"Array\", \"Record\", \"signature\"].includes(e.name) ? e.raw : r\n  );\n}\no(ce, \"createType\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createPropDef.ts\nvar le = /* @__PURE__ */ o((e, t) => {\n  let { description: r, required: n } = t;\n  return {\n    name: e,\n    type: ce(t),\n    required: n,\n    description: r,\n    defaultValue: ae(t)\n  };\n}, \"createTsPropDef\");\n\n// src/docs-tools/argTypes/docgen/createPropDef.ts\nfunction nt(e) {\n  return e != null ? l(e.name) : null;\n}\no(nt, \"createType\");\nfunction st(e) {\n  let { computed: t, func: r } = e;\n  return typeof t > \"u\" && typeof r > \"u\";\n}\no(st, \"isReactDocgenTypescript\");\nfunction it(e) {\n  return e ? e.name === \"string\" ? !0 : e.name === \"enum\" ? Array.isArray(e.value) && e.value.every(\n    ({ value: t }) => typeof t == \"string\" && t[0] === '\"' && t[t.length - 1] === '\"'\n  ) : !1 : !1;\n}\no(it, \"isStringValued\");\nfunction pt(e, t) {\n  if (e != null) {\n    let { value: r } = e;\n    if (!T(r))\n      return st(e) && it(t) ? l(JSON.stringify(r)) : l(r);\n  }\n  return null;\n}\no(pt, \"createDefaultValue\");\nfunction ue(e, t, r) {\n  let { description: n, required: s, defaultValue: i } = r;\n  return {\n    name: e,\n    type: nt(t),\n    required: s,\n    description: n,\n    defaultValue: pt(i, t)\n  };\n}\no(ue, \"createBasicPropDef\");\nfunction w(e, t) {\n  if (t?.includesJsDoc) {\n    let { description: r, extractedTags: n } = t;\n    r != null && (e.description = t.description);\n    let s = {\n      ...n,\n      params: n?.params?.map(\n        (i) => ({\n          name: i.getPrettyName(),\n          description: i.description\n        })\n      )\n    };\n    Object.values(s).filter(Boolean).length > 0 && (e.jsDocTags = s);\n  }\n  return e;\n}\no(w, \"applyJsDocResult\");\nvar at = /* @__PURE__ */ o((e, t, r) => {\n  let n = ue(e, t.type, t);\n  return n.sbType = b(t), w(n, r);\n}, \"javaScriptFactory\"), ct = /* @__PURE__ */ o((e, t, r) => {\n  let n = le(e, t);\n  return n.sbType = b(t), w(n, r);\n}, \"tsFactory\"), lt = /* @__PURE__ */ o((e, t, r) => {\n  let n = pe(e, t);\n  return n.sbType = b(t), w(n, r);\n}, \"flowFactory\"), ut = /* @__PURE__ */ o((e, t, r) => {\n  let n = ue(e, { name: \"unknown\" }, t);\n  return w(n, r);\n}, \"unknownFactory\"), I = /* @__PURE__ */ o((e) => {\n  switch (e) {\n    case \"JavaScript\":\n      return at;\n    case \"TypeScript\":\n      return ct;\n    case \"Flow\":\n      return lt;\n    default:\n      return ut;\n  }\n}, \"getPropDefFactory\");\n\n// src/docs-tools/argTypes/docgen/extractDocgenProps.ts\nvar me = /* @__PURE__ */ o((e) => e.type != null ? \"JavaScript\" : e.flowType != null ? \"Flow\" : e.tsType != null ? \"TypeScript\" : \"Unknown\",\n\"getTypeSystem\"), mt = /* @__PURE__ */ o((e) => {\n  let t = me(e[0]), r = I(t);\n  return e.map((n) => {\n    let s = n;\n    return n.type?.elements && (s = {\n      ...n,\n      type: {\n        ...n.type,\n        value: n.type.elements\n      }\n    }), fe(s.name, s, t, r);\n  });\n}, \"extractComponentSectionArray\"), ft = /* @__PURE__ */ o((e) => {\n  let t = Object.keys(e), r = me(e[t[0]]), n = I(r);\n  return t.map((s) => {\n    let i = e[s];\n    return i != null ? fe(s, i, r, n) : null;\n  }).filter(Boolean);\n}, \"extractComponentSectionObject\"), on = /* @__PURE__ */ o((e, t) => {\n  let r = Y(e, t);\n  return $(r) ? Array.isArray(r) ? mt(r) : ft(r) : [];\n}, \"extractComponentProps\");\nfunction fe(e, t, r, n) {\n  let s = Q(t.description);\n  return s.includesJsDoc && s.ignore ? null : {\n    propDef: n(e, t, s),\n    jsDocTags: s.extractedTags,\n    docgenInfo: t,\n    typeSystem: r\n  };\n}\no(fe, \"extractProp\");\nfunction nn(e) {\n  return e != null ? q(e) : \"\";\n}\no(nn, \"extractComponentDescription\");\n\n// src/docs-tools/argTypes/enhanceArgTypes.ts\nimport { combineParameters as yt } from \"@storybook/core/preview-api\";\nvar cn = /* @__PURE__ */ o((e) => {\n  let {\n    component: t,\n    argTypes: r,\n    parameters: { docs: n = {} }\n  } = e, { extractArgTypes: s } = n, i = s && t ? s(t) : {};\n  return i ? yt(i, r) : r;\n}, \"enhanceArgTypes\");\n\n// src/docs-tools/shared.ts\nvar ye = \"storybook/docs\", mn = `${ye}/panel`, fn = \"docs\", yn = `${ye}/snippet-rendered`, gt = /* @__PURE__ */ ((n) => (n.AUTO = \"auto\", n.\nCODE = \"code\", n.DYNAMIC = \"dynamic\", n))(gt || {});\n\n// src/docs-tools/hasDocsOrControls.ts\nvar dt = /(addons\\/|addon-|addon-essentials\\/)(docs|controls)/, dn = /* @__PURE__ */ o((e) => e.presetsList?.some((t) => dt.test(t.name)), \"\\\nhasDocsOrControls\");\nexport {\n  ye as ADDON_ID,\n  bo as MAX_DEFAULT_VALUE_SUMMARY_LENGTH,\n  ho as MAX_TYPE_SUMMARY_LENGTH,\n  mn as PANEL_ID,\n  fn as PARAM_KEY,\n  yn as SNIPPET_RENDERED,\n  gt as SourceType,\n  je as TypeSystem,\n  b as convert,\n  l as createSummaryValue,\n  cn as enhanceArgTypes,\n  nn as extractComponentDescription,\n  on as extractComponentProps,\n  mt as extractComponentSectionArray,\n  ft as extractComponentSectionObject,\n  q as getDocgenDescription,\n  Y as getDocgenSection,\n  z as hasDocgen,\n  dn as hasDocsOrControls,\n  T as isDefaultValueBlacklisted,\n  oe as isTooLongForDefaultValueSummary,\n  B as isTooLongForTypeSummary,\n  $ as isValidDocgenSection,\n  Po as normalizeNewlines,\n  Q as parseJsDoc,\n  M as str\n};\n"],"names":["global","factory","exports","this","tokenToString","token","NoParsletFoundError","EarlyEndOfParseError","UnexpectedTypeError","result","message","error","makePunctuationRule","type","text","getQuoted","position","char","mark","escaped","identifierStartRegex","identifierContinueRegex","getIdentifier","numberRegex","getNumber","_a","_b","identifierRule","value","makeKeyWordRule","prepends","stringValueRule","eofRule","numberRule","rules","breakingWhitespaceRegex","Lexer","current","next","previous","startOfLine","rule","partial","assertRootResult","assertPlainKeyValueOrRootResult","assertPlainKeyValueResult","assertPlainKeyValueOrNameResult","assertNumberOrVariadicNameResult","assertArrayOrTupleResult","isSquaredProperty","Precedence","Parser","grammar","textOrLexer","baseParser","precedence","left","parslet","types","parser","isQuestionMarkUnknownType","nullableParslet","composeParslet","options","curPrecedence","optionalParslet","numberParslet","parenthesisParslet","specialTypesParslet","notNullableParslet","createParameterListParslet","allowTrailingComma","elements","e","genericParslet","dot","objects","infer","unionParslet","baseGrammar","createNamePathParslet","allowSquareBracketsOnAnyType","allowJsdocNamePaths","pathGrammar","pathType","brackets","pathParser","parsed","right","createNameParslet","allowedAdditionalTokens","stringValueParslet","createSpecialNamePathParslet","allowedTypes","allowed","moduleParser","moduleResult","basePathGrammar","getParameters","parameters","p","getUnnamedParameters","createFunctionParslet","allowNamedParameters","allowNoReturnType","allowWithoutParenthesis","allowNewAsFunctionKeyword","newKeyword","hasParenthesis","createVariadicParslet","allowPostfix","allowEnclosingBrackets","element","symbolParslet","arrayBracketsParslet","createObjectParslet","objectFieldGrammar","allowKeyTypes","separator","fieldParser","field","optional","quote","createObjectFieldParslet","allowSquaredProperties","allowReadonly","allowOptional","readonlyProperty","parentParser","createKeyValueParslet","allowVariadic","variadic","jsdocBaseGrammar","jsdocGrammar","typeOfParslet","objectFieldGrammar$1","closureGrammar","assertsParslet","createTupleParslet","allowQuestionMark","typeList","keyOfParslet","importParslet","path","readonlyPropertyParslet","arrowFunctionParslet","genericArrowFunctionParslet","typeParameters","defaultValue","name","constraint","typeParameter","functionBase","intersectionParslet","predicateParslet","objectSquaredPropertyParslet","key","readonlyArrayParslet","conditionalParslet","extendsType","trueType","typescriptGrammar","parse","expression","mode","tryParse","modes","transform","parseResult","aParseResult","notAvailableTransform","extractSpecialParams","source","param","applyPosition","target","stringifyRules","stringified","transformed","storedStringifyRules","stringify","reservedWords","makeName","catharsisTransformRules","params","o","leftResult","rightValue","joiner","trailingDots","catharsisTransform","getQuoteStyle","getMemberType","nestResults","results","jtpRules","specialParams","entries","hasEventPrefix","quoteStyle","tModule","jtpTransform","identityTransformRules","visitorKeys","_traverse","node","parentNode","property","onEnter","onLeave","keysToVisit","traverse","De","t","Te","he","be","Pe","r","d","n","_c","_d","j","s","i","W","Se","Oe","h","ve","x","a","c","u","m","we","Ee","D","b","je","ke","T","M","z","$","Y","q","f","k","G","y","K","X","F","Fe","J","Je","N","R","P","S","Re","Ne","Ae","O","v","A","Ve","Be","Ce","_e","V","ge","E","L","U","de","xe","Ie","C","H","ze","$e","Ye","Q","qe","Ke","Xe","He","Ge","te","ee","re","Z","g","We","Qe","Ue","Me","B","oe","l","ne","se","Ze","et","tt","rt","ot","ie","pe","ae","ce","le","nt","st","it","pt","ue","w","at","ct","lt","ut","I","me","mt","fe","ft","on","nn","yt","cn","ye","yn","gt"],"mappings":"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","x_google_ignoreList":[0,1]}